<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cisco Fusion Router Configuration Generator</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        body {
            background-color: #f8f9fa;
        }
        .header-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 2rem 0;
            margin-bottom: 2rem;
        }
        .card {
            box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.075);
            margin-bottom: 1.5rem;
        }
        .step-indicator {
            display: flex;
            justify-content: space-between;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }
        .step {
            flex: 1;
            text-align: center;
            padding: 1rem;
            position: relative;
            min-width: 120px;
        }
        .step::before {
            content: '';
            position: absolute;
            top: 2rem;
            left: 50%;
            width: 100%;
            height: 2px;
            background-color: #dee2e6;
            z-index: -1;
        }
        .step:first-child::before {
            left: 50%;
            width: 50%;
        }
        .step:last-child::before {
            width: 50%;
            left: 0;
        }
        .step-number {
            width: 3rem;
            height: 3rem;
            border-radius: 50%;
            background-color: #dee2e6;
            color: #6c757d;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }
        .step.active .step-number {
            background-color: #667eea;
            color: white;
        }
        .step.completed .step-number {
            background-color: #28a745;
            color: white;
        }
        .interface-card {
            border-left: 4px solid #667eea;
        }
        .vrf-badge {
            background-color: #764ba2;
            color: white;
        }
        .config-preview {
            background-color: #1e1e1e;
            color: #d4d4d4;
            padding: 1rem;
            border-radius: 0.25rem;
            font-family: 'Courier New', monospace;
            font-size: 0.875rem;
            max-height: 600px;
            overflow-y: auto;
        }
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
        }
        .btn-primary:hover {
            background: linear-gradient(135deg, #5568d3 0%, #653a8a 100%);
        }
        #loading {
            display: none;
        }
        .handoff-table {
            font-size: 0.9rem;
        }
        .handoff-table th {
            background-color: #f8f9fa;
            font-weight: 600;
        }
        .vrf-config-section {
            background-color: #f8f9fa;
            border-radius: 0.25rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .router-config-tab {
            margin-top: 1rem;
        }
        /* Network Topology Diagram Styles */
        .topology-wrapper {
            height: calc(100vh - 250px);
            min-height: 600px;
            display: flex;
            gap: 0;
        }

        /* Left Sidebar for Border Interfaces */
        .border-interfaces-sidebar {
            width: 320px;
            background-color: white;
            border-right: 2px solid #dee2e6;
            overflow-y: auto;
            padding: 0;
            display: flex;
            flex-direction: column;
        }
        .sidebar-header {
            padding: 1rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-bottom: 2px solid #5568d3;
        }
        .sidebar-header h6 {
            margin: 0 0 0.75rem 0;
            font-weight: 600;
        }
        .sidebar-search {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 0.25rem;
            background: rgba(255,255,255,0.9);
        }
        .border-nodes-list {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }
        .border-node-section {
            margin-bottom: 0.75rem;
            border: 1px solid #dee2e6;
            border-radius: 0.25rem;
            background: white;
        }
        .border-node-header {
            padding: 0.75rem;
            background: #f8f9fa;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-weight: 600;
            border-bottom: 1px solid #dee2e6;
            transition: background 0.2s;
        }
        .border-node-header:hover {
            background: #e9ecef;
        }
        .border-node-header .toggle-icon {
            transition: transform 0.2s;
        }
        .border-node-header.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }
        .interface-list {
            max-height: 400px;
            overflow-y: auto;
        }
        .interface-item {
            padding: 0.75rem;
            border-bottom: 1px solid #f1f3f5;
            cursor: move;
            transition: all 0.2s;
            position: relative;
        }
        .interface-item:last-child {
            border-bottom: none;
        }
        .interface-item:hover {
            background: #f8f9fa;
            transform: translateX(2px);
        }
        .interface-item.dragging {
            opacity: 0.5;
            background: #e7f5ff;
        }
        .interface-item.configured {
            background: #d3f9d8;
            border-left: 4px solid #28a745;
        }
        .interface-item.configured::after {
            content: '\f00c';
            font-family: 'Font Awesome 6 Free';
            font-weight: 900;
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: #28a745;
        }
        .interface-vlan {
            font-weight: 600;
            color: #667eea;
            font-size: 0.95rem;
        }
        .interface-ip {
            font-size: 0.85rem;
            color: #495057;
            margin: 0.25rem 0;
        }
        .interface-vrf {
            display: inline-block;
            padding: 0.125rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: 600;
            margin-top: 0.25rem;
        }
        .interface-vrf.global {
            background: #e9ecef;
            color: #495057;
        }
        .interface-vrf.vrf {
            background: #764ba2;
            color: white;
        }

        /* Topology Canvas */
        .topology-canvas {
            flex: 1;
            background-color: #f8f9fa;
            position: relative;
            overflow: hidden;
        }
        .topology-controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            z-index: 10;
            background: white;
            padding: 0.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        .topology-controls button {
            padding: 0.375rem 0.75rem;
            font-size: 0.875rem;
        }
        .zoom-level {
            font-size: 0.875rem;
            font-weight: 600;
            color: #495057;
            min-width: 60px;
            text-align: center;
        }
        #topologyContainer {
            width: 100%;
            height: 100%;
            position: relative;
            cursor: grab;
        }
        #topologyContainer.panning {
            cursor: grabbing;
        }
        #topologySvg {
            display: block;
        }

        /* Device Nodes */
        .device-node {
            cursor: default;
        }
        .device-node.fusion-router {
            cursor: pointer;
        }
        .device-node.fusion-router.drag-over {
            filter: drop-shadow(0 0 10px rgba(40, 167, 69, 0.6));
        }
        .device-rect {
            fill: white;
            stroke: #667eea;
            stroke-width: 2;
            rx: 8;
            transition: all 0.2s;
        }
        .device-node.fusion-router .device-rect {
            stroke: #764ba2;
        }
        .device-node.fusion-router.drag-over .device-rect {
            fill: #d3f9d8;
            stroke: #28a745;
            stroke-width: 3;
        }
        .device-label {
            font-size: 16px;
            font-weight: 600;
            fill: #333;
            text-anchor: middle;
            pointer-events: none;
        }
        .device-type {
            font-size: 13px;
            fill: #6c757d;
            text-anchor: middle;
            pointer-events: none;
        }

        /* Connection Lines */
        .connection-path {
            fill: none;
            stroke-width: 3;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .connection-path.configured {
            stroke: #28a745;
        }
        .connection-path.unconfigured {
            stroke: #adb5bd;
            stroke-dasharray: 8,4;
        }
        .connection-path:hover {
            stroke-width: 4;
            filter: brightness(1.2);
        }
        .connection-group {
            pointer-events: all;
        }
        .connection-label-bg {
            fill: white;
            stroke: #dee2e6;
            stroke-width: 1;
            rx: 3;
        }
        .connection-label-text {
            font-size: 12px;
            font-weight: 600;
            text-anchor: middle;
            fill: #495057;
            pointer-events: none;
        }
        .connection-vrf-badge {
            font-size: 11px;
            font-weight: 600;
            text-anchor: middle;
            fill: white;
            pointer-events: none;
        }
        .connection-dot {
            transition: all 0.2s ease;
            r: 5;
        }
        .connection-dot.configured {
            fill: #28a745;
        }
        .connection-dot.unconfigured {
            fill: #adb5bd;
        }
        .connection-delete-btn {
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .connection-group:hover .connection-delete-btn {
            opacity: 1;
        }
        .connection-delete-circle {
            fill: #dc3545;
            stroke: white;
            stroke-width: 2;
        }
        .connection-delete-icon {
            fill: white;
            font-size: 12px;
            font-weight: 900;
            text-anchor: middle;
            pointer-events: none;
        }

        /* Interface Labels */
        .interface-label {
            font-size: 11px;
            font-weight: 600;
            fill: #495057;
            text-anchor: middle;
            pointer-events: none;
        }
        .interface-label-bg {
            fill: #fff3cd;
            stroke: #ffc107;
            stroke-width: 1;
            rx: 3;
        }
        .border-interface-list {
            font-size: 10px;
            fill: #495057;
            pointer-events: none;
        }
        .border-interface-label {
            font-size: 11px;
            font-weight: 600;
            fill: #667eea;
            pointer-events: none;
        }
        .fusion-interface-list {
            font-size: 10px;
            fill: #495057;
            pointer-events: none;
        }
        .interface-port-label {
            font-size: 10px;
            font-weight: 500;
            fill: #764ba2;
            pointer-events: none;
        }

        /* Drag Ghost Line */
        #dragGhostLine {
            stroke: #667eea;
            stroke-width: 2;
            stroke-dasharray: 5,5;
            opacity: 0.6;
            pointer-events: none;
        }

        /* Legend */
        .topology-legend {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex;
            gap: 2rem;
            font-size: 0.875rem;
            z-index: 10;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .legend-line {
            width: 40px;
            height: 3px;
        }
        .legend-line.unconfigured {
            background: repeating-linear-gradient(
                to right,
                #adb5bd 0,
                #adb5bd 5px,
                transparent 5px,
                transparent 10px
            );
        }
        .legend-line.configured {
            background: #28a745;
        }

        /* Scrollbar Styling */
        .border-interfaces-sidebar::-webkit-scrollbar,
        .interface-list::-webkit-scrollbar {
            width: 8px;
        }
        .border-interfaces-sidebar::-webkit-scrollbar-track,
        .interface-list::-webkit-scrollbar-track {
            background: #f1f3f5;
        }
        .border-interfaces-sidebar::-webkit-scrollbar-thumb,
        .interface-list::-webkit-scrollbar-thumb {
            background: #adb5bd;
            border-radius: 4px;
        }
        .border-interfaces-sidebar::-webkit-scrollbar-thumb:hover,
        .interface-list::-webkit-scrollbar-thumb:hover {
            background: #868e96;
        }

        /* Full-width layout for Step 4 */
        #step4 {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
            background: white;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        #step4 .card {
            flex-shrink: 0;
            margin: 0;
            border-radius: 0;
            border: none;
            border-bottom: 2px solid #dee2e6;
        }

        /* Modern Card-Based Topology Styles */
        .fusion-router-tab-pane {
            padding: 2rem 0;
            min-height: 600px;
        }
        .router-card {
            border: 2px solid #764ba2;
            border-radius: 1rem;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            margin-bottom: 2rem;
        }
        .router-card-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .router-card-body {
            padding: 2rem;
            background: white;
        }
        .connection-cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 1.5rem;
            margin-top: 1.5rem;
        }
        .connection-card {
            border: 1px solid #dee2e6;
            border-radius: 0.5rem;
            padding: 1.25rem;
            background: white;
            transition: all 0.2s;
            position: relative;
        }
        .connection-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-color: #667eea;
        }
        .connection-card.configured {
            border-left: 4px solid #28a745;
            background: linear-gradient(to right, #d3f9d8 0%, white 10%);
        }
        .connection-card.unconfigured {
            border-left: 4px solid #adb5bd;
            background: linear-gradient(to right, #f8f9fa 0%, white 10%);
        }
        .connection-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 1rem;
        }
        .connection-vlan-badge {
            background: #667eea;
            color: white;
            padding: 0.375rem 0.75rem;
            border-radius: 0.375rem;
            font-weight: 600;
            font-size: 0.95rem;
        }
        .connection-status-badge {
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: 600;
        }
        .connection-status-badge.configured {
            background: #28a745;
            color: white;
        }
        .connection-status-badge.unconfigured {
            background: #adb5bd;
            color: white;
        }
        .connection-details {
            font-size: 0.9rem;
            color: #495057;
        }
        .connection-detail-row {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid #f1f3f5;
        }
        .connection-detail-row:last-child {
            border-bottom: none;
        }
        .connection-detail-label {
            font-weight: 600;
            color: #6c757d;
        }
        .connection-detail-value {
            text-align: right;
            font-family: 'Courier New', monospace;
        }
        .add-connection-card {
            border: 2px dashed #667eea;
            border-radius: 0.5rem;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: linear-gradient(135deg, rgba(102,126,234,0.05) 0%, rgba(118,75,162,0.05) 100%);
        }
        .add-connection-card:hover {
            background: linear-gradient(135deg, rgba(102,126,234,0.1) 0%, rgba(118,75,162,0.1) 100%);
            border-color: #764ba2;
        }
        .add-connection-icon {
            font-size: 3rem;
            color: #667eea;
            margin-bottom: 1rem;
        }
        .border-node-selector {
            max-height: 400px;
            overflow-y: auto;
        }
        .border-node-option {
            border: 1px solid #dee2e6;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .border-node-option:hover {
            background: #f8f9fa;
            border-color: #667eea;
        }
        .border-node-option.selected {
            background: #e7f5ff;
            border-color: #667eea;
            border-width: 2px;
        }
        .stats-row {
            display: flex;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }
        .stat-card {
            flex: 1;
            min-width: 200px;
            background: linear-gradient(135deg, #f8f9fa 0%, white 100%);
            border: 1px solid #dee2e6;
            border-radius: 0.5rem;
            padding: 1.25rem;
            text-align: center;
        }
        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: #667eea;
            margin-bottom: 0.5rem;
        }
        .stat-label {
            color: #6c757d;
            font-size: 0.9rem;
            font-weight: 600;
        }

        /* Table-based mapping styles */
        .mapping-table {
            width: 100%;
            margin-bottom: 1.5rem;
        }
        .mapping-table th {
            background-color: #667eea;
            color: white;
            padding: 0.75rem;
            font-weight: 600;
        }
        .mapping-table td {
            padding: 0.75rem;
            vertical-align: middle;
        }
        .mapping-table tbody tr:hover {
            background-color: #f8f9fa;
        }
        .mapping-row-configured {
            background-color: #d4edda;
        }
        .border-node-section-table {
            margin-bottom: 2rem;
        }
        .border-node-header-table {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
            color: white;
            padding: 1rem;
            border-radius: 0.25rem;
            margin-bottom: 0.5rem;
            font-weight: 600;
            font-size: 1.1rem;
        }
        #topologyPreview {
            margin-top: 2rem;
        }
        #networkDiagram {
            border: 2px solid #dee2e6;
            border-radius: 0.25rem;
            background-color: #ffffff;
        }
    </style>

    <!-- vis.js Network for topology visualization -->
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <link href="https://unpkg.com/vis-network/styles/vis-network.min.css" rel="stylesheet" type="text/css" />
</head>
<body>
    <div class="header-section">
        <div class="container">
            <h1><i class="fas fa-network-wired"></i> Cisco Fusion Router Config Generator</h1>
            <p class="lead mb-0">Enhanced configuration generator with multi-router, VRF, and interface mode support</p>
        </div>
    </div>

    <div class="container" id="mainContainer">
        <!-- Step Indicator -->
        <div class="step-indicator">
            <div class="step active" id="step1-indicator">
                <div class="step-number">1</div>
                <div>Upload Configs</div>
            </div>
            <div class="step" id="step2-indicator">
                <div class="step-number">2</div>
                <div>Fusion Router Setup</div>
            </div>
            <div class="step" id="step3-indicator">
                <div class="step-number">3</div>
                <div>Interface Mode</div>
            </div>
            <div class="step" id="step4-indicator">
                <div class="step-number">4</div>
                <div>Handoff Mapping</div>
            </div>
            <div class="step" id="step5-indicator">
                <div class="step-number">5</div>
                <div>VRF Configuration</div>
            </div>
            <div class="step" id="step6-indicator">
                <div class="step-number">6</div>
                <div>Generate & Download</div>
            </div>
        </div>

        <!-- Step 1: Upload Border Node Configurations -->
        <div id="step1" class="step-content">
            <div class="card">
                <div class="card-header bg-primary text-white">
                    <h5 class="mb-0"><i class="fas fa-upload"></i> Step 1: Upload Border Node Configurations</h5>
                </div>
                <div class="card-body">
                    <p>Upload one or more Cisco IOS border node configuration files (.txt, .cfg, or .conf)</p>
                    <div class="mb-3">
                        <input type="file" class="form-control" id="configFiles" multiple accept=".txt,.cfg,.conf">
                        <div class="form-text">You can select multiple files at once</div>
                    </div>
                    <button class="btn btn-primary" id="uploadBtn" onclick="uploadConfigs()">
                        <i class="fas fa-cloud-upload-alt"></i> Upload and Parse Configurations
                    </button>
                    <div id="loading" class="mt-3">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <span class="ms-2">Processing configurations...</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Step 2: Fusion Router Setup -->
        <div id="step2" class="step-content" style="display: none;">
            <div class="card">
                <div class="card-header bg-primary text-white">
                    <h5 class="mb-0"><i class="fas fa-server"></i> Step 2: Fusion Router Setup</h5>
                </div>
                <div class="card-body">
                    <div id="borderNodeSummary" class="mb-4"></div>

                    <div class="mb-4">
                        <label class="form-label"><strong>Number of Fusion Routers *</strong></label>
                        <select class="form-select" id="numFusionRouters" onchange="updateFusionRouterInputs()">
                            <option value="1" selected>Single Fusion Router</option>
                            <option value="2">Dual Fusion Routers (Redundant Pair)</option>
                        </select>
                        <div class="form-text">Select 2 for redundant fusion router pairs</div>
                    </div>

                    <div id="fusionRouterConfigs"></div>

                    <!-- iBGP Configuration Section -->
                    <div id="ibgpConfigSection" style="display: none;">
                        <div class="card mt-3">
                            <div class="card-header" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                                <h6 class="mb-0"><i class="fas fa-exchange-alt"></i> iBGP Configuration Between Fusion Routers</h6>
                            </div>
                            <div class="card-body">
                                <div class="form-check mb-3">
                                    <input class="form-check-input" type="checkbox" id="enableIbgp"
                                           onchange="toggleIbgpConfig()">
                                    <label class="form-check-label" for="enableIbgp">
                                        <strong>Enable iBGP peering between fusion routers</strong>
                                    </label>
                                    <div class="form-text">Creates route exchange between redundant fusion routers</div>
                                </div>

                                <div id="ibgpConfigFields" style="display: none;">
                                    <div class="alert alert-info">
                                        <i class="fas fa-info-circle"></i>
                                        <strong>Note:</strong> Both fusion routers must use the same BGP AS number for iBGP.
                                        iBGP peering will use Loopback0 addresses for stability.
                                    </div>

                                    <div class="row">
                                        <div class="col-md-6 mb-3">
                                            <label class="form-label">Router 1 Loopback0 IP</label>
                                            <input type="text" class="form-control" id="ibgpRouter1Loopback"
                                                   readonly style="background-color: #f8f9fa;">
                                            <div class="form-text">Auto-populated from BGP Router ID</div>
                                        </div>
                                        <div class="col-md-6 mb-3">
                                            <label class="form-label">Router 2 Loopback0 IP</label>
                                            <input type="text" class="form-control" id="ibgpRouter2Loopback"
                                                   readonly style="background-color: #f8f9fa;">
                                            <div class="form-text">Auto-populated from BGP Router ID</div>
                                        </div>
                                    </div>

                                    <!-- BFD Configuration -->
                                    <div class="form-check mb-3">
                                        <input class="form-check-input" type="checkbox" id="ibgpBfdEnabled" checked>
                                        <label class="form-check-label" for="ibgpBfdEnabled">
                                            <strong>Enable BFD for iBGP sessions</strong>
                                        </label>
                                        <div class="form-text">Bidirectional Forwarding Detection for fast failure detection</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- OSPF Underlay Configuration Section -->
                    <div id="ospfUnderlaySection" style="display: none;">
                        <div class="card mt-3">
                            <div class="card-header" style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white;">
                                <h6 class="mb-0"><i class="fas fa-route"></i> OSPF Underlay Configuration</h6>
                            </div>
                            <div class="card-body">
                                <div class="alert alert-info">
                                    <i class="fas fa-info-circle"></i>
                                    <strong>Required for iBGP:</strong> OSPF provides Layer 3 reachability between fusion routers for iBGP Loopback peering.
                                </div>

                                <div class="row mb-3">
                                    <div class="col-md-6">
                                        <label class="form-label">OSPF Process ID</label>
                                        <input type="number" class="form-control" id="ospfProcessId" value="1" min="1" max="65535">
                                        <div class="form-text">OSPF process identifier (1-65535)</div>
                                    </div>
                                    <div class="col-md-6">
                                        <label class="form-label">OSPF Area</label>
                                        <input type="number" class="form-control" id="ospfArea" value="0" min="0">
                                        <div class="form-text">Typically 0 for backbone area</div>
                                    </div>
                                </div>

                                <h6 class="mt-4 mb-3">Interconnect Interface Configuration</h6>

                                <div class="mb-3">
                                    <label class="form-label"><strong>Interconnect Mode</strong></label>
                                    <div class="row">
                                        <div class="col-md-4">
                                            <div class="form-check">
                                                <input class="form-check-input" type="radio" name="ospfInterfaceMode"
                                                       id="ospfModePhysical" value="physical" checked
                                                       onchange="updateOspfInterfaceInputs()">
                                                <label class="form-check-label" for="ospfModePhysical">
                                                    <strong>Physical Interface</strong><br>
                                                    <small class="text-muted">Direct L3 point-to-point</small>
                                                </label>
                                            </div>
                                        </div>
                                        <div class="col-md-4">
                                            <div class="form-check">
                                                <input class="form-check-input" type="radio" name="ospfInterfaceMode"
                                                       id="ospfModeSVI" value="svi"
                                                       onchange="updateOspfInterfaceInputs()">
                                                <label class="form-check-label" for="ospfModeSVI">
                                                    <strong>SVI (VLAN Interface)</strong><br>
                                                    <small class="text-muted">L3 on VLAN, L2 trunk</small>
                                                </label>
                                            </div>
                                        </div>
                                        <div class="col-md-4">
                                            <div class="form-check">
                                                <input class="form-check-input" type="radio" name="ospfInterfaceMode"
                                                       id="ospfModeSubif" value="subinterface"
                                                       onchange="updateOspfInterfaceInputs()">
                                                <label class="form-check-label" for="ospfModeSubif">
                                                    <strong>Subinterface</strong><br>
                                                    <small class="text-muted">802.1Q subinterfaces</small>
                                                </label>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div id="ospfInterfaceInputs">
                                    <!-- Dynamically populated based on mode selection -->
                                </div>

                                <!-- BFD Configuration -->
                                <h6 class="mt-4 mb-3">BFD Configuration</h6>
                                <div class="form-check mb-3">
                                    <input class="form-check-input" type="checkbox" id="ospfBfdEnabled" checked>
                                    <label class="form-check-label" for="ospfBfdEnabled">
                                        <strong>Enable BFD for OSPF</strong>
                                    </label>
                                    <div class="form-text">Bidirectional Forwarding Detection for fast convergence</div>
                                </div>

                                <div class="row" id="ospfBfdParams">
                                    <div class="col-md-4">
                                        <label class="form-label">Interval (ms)</label>
                                        <input type="number" class="form-control" id="ospfBfdInterval" value="250">
                                    </div>
                                    <div class="col-md-4">
                                        <label class="form-label">Min RX (ms)</label>
                                        <input type="number" class="form-control" id="ospfBfdMinRx" value="250">
                                    </div>
                                    <div class="col-md-4">
                                        <label class="form-label">Multiplier</label>
                                        <input type="number" class="form-control" id="ospfBfdMultiplier" value="3">
                                    </div>
                                </div>

                                <!-- Authentication (Optional) -->
                                <h6 class="mt-4 mb-3">Authentication (Optional)</h6>
                                <div class="mb-3">
                                    <label class="form-label">OSPF Authentication</label>
                                    <select class="form-select" id="ospfAuth" onchange="toggleOspfAuth()">
                                        <option value="none" selected>None</option>
                                        <option value="md5">MD5</option>
                                    </select>
                                </div>

                                <div id="ospfAuthParams" style="display: none;">
                                    <div class="row">
                                        <div class="col-md-6">
                                            <label class="form-label">Key ID</label>
                                            <input type="number" class="form-control" id="ospfKeyId" value="1" min="1" max="255">
                                        </div>
                                        <div class="col-md-6">
                                            <label class="form-label">Key String</label>
                                            <input type="password" class="form-control" id="ospfKeyString" placeholder="Enter MD5 key">
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <button class="btn btn-primary mt-3" onclick="proceedToStep3()">
                        <i class="fas fa-arrow-right"></i> Next: Select Interface Mode
                    </button>
                </div>
            </div>
        </div>

        <!-- Step 3: Interface Mode Selection -->
        <div id="step3" class="step-content" style="display: none;">
            <div class="card">
                <div class="card-header bg-primary text-white">
                    <h5 class="mb-0"><i class="fas fa-ethernet"></i> Step 3: Interface Mode Selection</h5>
                </div>
                <div class="card-body">
                    <p>Select how interfaces should be configured on the fusion router(s)</p>

                    <div class="row">
                        <div class="col-md-4 mb-3">
                            <div class="card h-100">
                                <div class="card-body">
                                    <div class="form-check">
                                        <input class="form-check-input" type="radio" name="interfaceMode" id="modeRouted" value="routed" checked>
                                        <label class="form-check-label w-100" for="modeRouted">
                                            <h6>Routed Interfaces</h6>
                                            <small class="text-muted">Direct L3 configuration on physical interfaces</small>
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4 mb-3">
                            <div class="card h-100">
                                <div class="card-body">
                                    <div class="form-check">
                                        <input class="form-check-input" type="radio" name="interfaceMode" id="modeSVI" value="svi">
                                        <label class="form-check-label w-100" for="modeSVI">
                                            <h6>SVI Mode</h6>
                                            <small class="text-muted">L3 on VLAN interfaces, L2 trunk on physical ports</small>
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4 mb-3">
                            <div class="card h-100">
                                <div class="card-body">
                                    <div class="form-check">
                                        <input class="form-check-input" type="radio" name="interfaceMode" id="modeSubinterface" value="subinterface">
                                        <label class="form-check-label w-100" for="modeSubinterface">
                                            <h6>Subinterface Mode</h6>
                                            <small class="text-muted">802.1Q subinterfaces for WAN handoffs</small>
                                        </label>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <button class="btn btn-secondary me-2" onclick="showStep(2)">
                        <i class="fas fa-arrow-left"></i> Back
                    </button>
                    <button class="btn btn-primary" onclick="proceedToStep4()">
                        <i class="fas fa-arrow-right"></i> Next: Configure Handoffs
                    </button>
                </div>
            </div>
        </div>

        <!-- Step 4: Handoff Mapping -->
        <div id="step4" class="step-content" style="display: none;">
            <div class="card">
                <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
                    <h5 class="mb-0"><i class="fas fa-network-wired"></i> Step 4: Handoff Mapping Configuration</h5>
                    <div>
                        <button class="btn btn-outline-light btn-sm me-2" onclick="showStep(3)">
                            <i class="fas fa-arrow-left"></i> Back
                        </button>
                        <button class="btn btn-light btn-sm" onclick="proceedToStep5()">
                            <i class="fas fa-arrow-right"></i> Next: Configure VRFs
                        </button>
                    </div>
                </div>
            </div>

            <!-- NEW: Table-Based Mapping Interface -->
            <div class="container-fluid mt-3">
                <div class="card">
                    <div class="card-body">
                        <p class="mb-3">
                            <i class="fas fa-info-circle"></i>
                            Configure interface handoffs by selecting the Fusion router and interface for each border node VLAN interface.
                        </p>

                        <!-- Border Node Tables Container -->
                        <div id="borderNodeTablesContainer">
                            <!-- Tables will be dynamically generated here (one per border node) -->
                        </div>

                        <!-- Action Buttons -->
                        <div class="mt-4 d-flex justify-content-between align-items-center">
                            <button class="btn btn-secondary" onclick="showStep(3)">
                                <i class="fas fa-arrow-left"></i> Back to Interface Modes
                            </button>
                            <div>
                                <button class="btn btn-info me-2" onclick="previewTopology()">
                                    <i class="fas fa-project-diagram"></i> Preview Network Topology
                                </button>
                                <button class="btn btn-primary" onclick="proceedToStep5()">
                                    Next: Configure VRFs <i class="fas fa-arrow-right"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Topology Preview Modal -->
            <div class="modal fade" id="topologyPreviewModal" tabindex="-1" aria-labelledby="topologyPreviewLabel" aria-hidden="true">
                <div class="modal-dialog modal-xl">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="topologyPreviewLabel">
                                <i class="fas fa-project-diagram"></i> Network Topology Preview
                            </h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <div id="networkDiagram" style="height: 600px;"></div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ARCHIVED: Old SVG-based drag-and-drop interface (kept for reference, not displayed) -->
            <!--
            <div id="routerViewSelector" class="container-fluid mt-3" style="display: none;">
                <div class="card mb-3">
                    <div class="card-body">
                        <h6 class="card-subtitle mb-2 text-muted">Select Router View:</h6>
                        <div id="routerViewButtons" class="btn-group" role="group">
                        </div>
                    </div>
                </div>
            </div>

            <div class="container-fluid mt-3" style="display: none;">
                <div class="card">
                    <div class="card-body">
                        <div class="row">
                            <div class="col-md-9">
                                <div id="topologyContainer" style="width: 100%; height: 600px; overflow: auto; border: 1px solid #dee2e6; border-radius: 4px; background-color: #f8f9fa;">
                                </div>
                            </div>
                            <div class="col-md-3">
                                <div class="card">
                                    <div class="card-header">
                                        <h6 class="mb-0">Border Nodes</h6>
                                    </div>
                                    <div class="card-body p-2" style="max-height: 600px; overflow-y: auto;">
                                        <div id="borderNodesList">
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            -->
        </div>

        <!-- Connection Configuration Modal -->
        <div class="modal fade" id="connectionModal" tabindex="-1" aria-labelledby="connectionModalLabel" aria-hidden="true" data-bs-backdrop="static" data-bs-keyboard="false">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="connectionModalLabel">Configure Connection</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div id="connectionConfigForm"></div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-primary" onclick="saveConnectionConfig()">
                            <i class="fas fa-save"></i> Save Configuration
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Step 5: VRF Configuration -->
        <div id="step5" class="step-content" style="display: none;">
            <div class="card">
                <div class="card-header bg-primary text-white">
                    <h5 class="mb-0"><i class="fas fa-project-diagram"></i> Step 5: VRF Configuration</h5>
                </div>
                <div class="card-body">
                    <p>Configure VRF parameters including Route Distinguisher and Route Targets</p>
                    <div id="vrfConfigSection"></div>
                    <button class="btn btn-secondary me-2" onclick="showStep(4)">
                        <i class="fas fa-arrow-left"></i> Back
                    </button>
                    <button class="btn btn-primary" onclick="generateConfiguration()">
                        <i class="fas fa-magic"></i> Generate Configuration
                    </button>
                </div>
            </div>
        </div>

        <!-- Step 6: Preview and Download -->
        <div id="step6" class="step-content" style="display: none;">
            <div class="card">
                <div class="card-header bg-primary text-white">
                    <h5 class="mb-0"><i class="fas fa-file-code"></i> Step 6: Preview and Download Configuration</h5>
                </div>
                <div class="card-body">
                    <div class="alert alert-success" role="alert">
                        <i class="fas fa-check-circle"></i> Configuration(s) generated successfully!
                    </div>

                    <ul class="nav nav-tabs" id="configTabs" role="tablist"></ul>
                    <div class="tab-content router-config-tab" id="configTabContent"></div>

                    <div class="mt-3">
                        <button class="btn btn-secondary me-2" onclick="showStep(5)">
                            <i class="fas fa-arrow-left"></i> Back to VRF Configuration
                        </button>
                        <button class="btn btn-success" onclick="downloadAllConfigs()">
                            <i class="fas fa-download"></i> Download All Configurations
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        let borderNodeConfigs = [];
        let generatedConfigs = {};
        let fusionRouters = [];
        let handoffs = [];
        let connectionConfigs = {}; // Stores config for each connection
        let currentConnection = null; // Currently selected connection for modal
        let currentInterfaceMode = 'routed'; // Selected interface mode

        // Topology visualization state
        let zoomLevel = 1.0;
        let panX = 0;
        let panY = 0;
        let isPanning = false;
        let lastPanX = 0;
        let lastPanY = 0;
        let isDragging = false;
        let currentDragData = null;
        let fusionRouterPositions = {}; // Store fusion router SVG positions for drop detection
        let currentFusionRouterView = null; // Which fusion router diagram is currently shown (null = all)

        // ============================================
        // INTERFACE NAME VALIDATION
        // ============================================

        /**
         * Validate Cisco interface name (matches backend regex)
         * Accepts both full names (GigabitEthernet) and abbreviations (Gi, Te, Ten, etc.)
         */
        function validateInterfaceName(interfaceName) {
            if (!interfaceName || interfaceName.trim() === '') {
                return { valid: false, error: 'Interface name is required' };
            }

            const trimmed = interfaceName.trim();
            // Match backend regex pattern (case insensitive)
            const pattern = /^(GigabitEthernet|Gi|TenGigabitEthernet|Ten|Te|FastEthernet|Fa|FortyGigabitEthernet|FortyGigE|Fo|HundredGigE|Hu|TwentyFiveGigE|Twe|Port-channel|Po)[\d/\.]+$/i;

            if (!pattern.test(trimmed)) {
                return {
                    valid: false,
                    error: 'Invalid interface format. Examples: GigabitEthernet1/0/1, Gi1/0/1, Ten1/0/1, TenGigabitEthernet1/0/1, Port-channel10'
                };
            }

            return { valid: true, error: null };
        }

        /**
         * Show inline validation error for an input field
         */
        function showValidationError(inputElement, errorMessage) {
            inputElement.classList.add('is-invalid');
            inputElement.classList.remove('is-valid');

            // Remove existing error message if any
            let errorDiv = inputElement.parentElement.querySelector('.invalid-feedback');
            if (errorDiv) {
                errorDiv.remove();
            }

            // Add new error message
            errorDiv = document.createElement('div');
            errorDiv.className = 'invalid-feedback d-block';
            errorDiv.textContent = errorMessage;
            inputElement.parentElement.appendChild(errorDiv);
        }

        /**
         * Show validation success for an input field
         */
        function showValidationSuccess(inputElement) {
            inputElement.classList.remove('is-invalid');
            inputElement.classList.add('is-valid');

            // Remove error message if any
            const errorDiv = inputElement.parentElement.querySelector('.invalid-feedback');
            if (errorDiv) {
                errorDiv.remove();
            }
        }

        /**
         * Clear validation styling from an input field
         */
        function clearValidation(inputElement) {
            inputElement.classList.remove('is-invalid', 'is-valid');
            const errorDiv = inputElement.parentElement.querySelector('.invalid-feedback');
            if (errorDiv) {
                errorDiv.remove();
            }
        }

        /**
         * Attach validation listeners to OSPF interface fields
         */
        function attachOspfInterfaceValidation() {
            // Wait a bit to ensure DOM elements exist
            setTimeout(() => {
                const router1Interface = document.getElementById('ospfRouter1Interface');
                const router2Interface = document.getElementById('ospfRouter2Interface');

                if (router1Interface) {
                    router1Interface.addEventListener('blur', function() {
                        const result = validateInterfaceName(this.value);
                        if (!result.valid) {
                            showValidationError(this, result.error);
                        } else {
                            showValidationSuccess(this);
                        }
                    });

                    router1Interface.addEventListener('input', function() {
                        // Clear validation on input to allow user to type
                        if (this.classList.contains('is-invalid') || this.classList.contains('is-valid')) {
                            clearValidation(this);
                        }
                    });
                }

                if (router2Interface) {
                    router2Interface.addEventListener('blur', function() {
                        const result = validateInterfaceName(this.value);
                        if (!result.valid) {
                            showValidationError(this, result.error);
                        } else {
                            showValidationSuccess(this);
                        }
                    });

                    router2Interface.addEventListener('input', function() {
                        // Clear validation on input to allow user to type
                        if (this.classList.contains('is-invalid') || this.classList.contains('is-valid')) {
                            clearValidation(this);
                        }
                    });
                }
            }, 300);
        }

        function showStep(stepNumber) {
            // Hide all steps
            document.querySelectorAll('.step-content').forEach(el => el.style.display = 'none');

            // Show target step
            document.getElementById(`step${stepNumber}`).style.display = 'block';

            // Update indicators
            document.querySelectorAll('.step').forEach((el, index) => {
                el.classList.remove('active', 'completed');
                if (index + 1 < stepNumber) {
                    el.classList.add('completed');
                } else if (index + 1 === stepNumber) {
                    el.classList.add('active');
                }
            });
        }

        async function uploadConfigs() {
            const files = document.getElementById('configFiles').files;

            if (files.length === 0) {
                alert('Please select at least one configuration file');
                return;
            }

            const formData = new FormData();
            for (let file of files) {
                formData.append('config_files', file);
            }

            document.getElementById('loading').style.display = 'block';
            document.getElementById('uploadBtn').disabled = true;

            try {
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'Upload failed');
                }

                borderNodeConfigs = data.configs;
                displayBorderNodeSummary();
                updateFusionRouterInputs();
                showStep(2);

            } catch (error) {
                alert('Error: ' + error.message);
            } finally {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('uploadBtn').disabled = false;
            }
        }

        function displayBorderNodeSummary() {
            const summary = document.getElementById('borderNodeSummary');
            let html = '<h6>Detected Border Nodes:</h6><div class="row">';

            borderNodeConfigs.forEach(config => {
                html += `
                    <div class="col-md-6 mb-3">
                        <div class="card border-primary">
                            <div class="card-body">
                                <h6 class="card-title"><i class="fas fa-server"></i> ${config.hostname}</h6>
                                <p class="card-text mb-1"><strong>Loopback0:</strong> ${config.loopback0_ip}</p>
                                <p class="card-text mb-1"><strong>BGP AS:</strong> ${config.bgp.as_number}</p>
                                <p class="card-text mb-0"><strong>VLAN Interfaces:</strong> ${config.vlan_interfaces.length} (/30 subnets)</p>
                            </div>
                        </div>
                    </div>
                `;
            });

            html += '</div>';
            summary.innerHTML = html;
        }

        function updateFusionRouterInputs() {
            const numRouters = parseInt(document.getElementById('numFusionRouters').value);
            const container = document.getElementById('fusionRouterConfigs');
            let html = '';

            for (let i = 1; i <= numRouters; i++) {
                html += `
                    <div class="card mb-3">
                        <div class="card-header">
                            <h6 class="mb-0">Fusion Router ${i} Configuration</h6>
                        </div>
                        <div class="card-body">
                            <div class="row">
                                <div class="col-md-4 mb-3">
                                    <label for="fusionHostname${i}" class="form-label">Hostname *</label>
                                    <input type="text" class="form-control" id="fusionHostname${i}"
                                           placeholder="fusion-router-0${i}" required>
                                </div>
                                <div class="col-md-4 mb-3">
                                    <label for="fusionRouterId${i}" class="form-label">BGP Router ID *</label>
                                    <input type="text" class="form-control" id="fusionRouterId${i}"
                                           placeholder="10.0.0.${i}" required>
                                    <div class="form-text">Typically a loopback IP</div>
                                </div>
                                <div class="col-md-4 mb-3">
                                    <label for="fusionAsNumber${i}" class="form-label">BGP AS Number *</label>
                                    <input type="number" class="form-control" id="fusionAsNumber${i}"
                                           placeholder="6470${i}" required>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            container.innerHTML = html;

            // Show/hide iBGP and OSPF sections based on number of routers
            const ibgpSection = document.getElementById('ibgpConfigSection');
            const ospfSection = document.getElementById('ospfUnderlaySection');

            if (numRouters === 2) {
                ibgpSection.style.display = 'block';
                ospfSection.style.display = 'none'; // Will be shown when iBGP is enabled
            } else {
                ibgpSection.style.display = 'none';
                ospfSection.style.display = 'none';
                document.getElementById('enableIbgp').checked = false;
                document.getElementById('ibgpConfigFields').style.display = 'none';
            }

            // Initialize OSPF interface inputs on load
            if (numRouters === 2) {
                updateOspfInterfaceInputs();
            }
        }

        function toggleIbgpConfig() {
            const enabled = document.getElementById('enableIbgp').checked;
            const numRouters = parseInt(document.getElementById('numFusionRouters').value);

            if (enabled && numRouters < 2) {
                alert('iBGP requires at least 2 fusion routers');
                document.getElementById('enableIbgp').checked = false;
                return;
            }

            document.getElementById('ibgpConfigFields').style.display = enabled ? 'block' : 'none';

            // Show/hide OSPF section when iBGP is enabled/disabled
            const ospfSection = document.getElementById('ospfUnderlaySection');
            if (enabled) {
                ospfSection.style.display = 'block';

                // Auto-populate loopback IPs from BGP Router IDs
                const routerId1 = document.getElementById('fusionRouterId1').value;
                const routerId2 = document.getElementById('fusionRouterId2').value;

                if (routerId1) {
                    document.getElementById('ibgpRouter1Loopback').value = routerId1;
                }
                if (routerId2) {
                    document.getElementById('ibgpRouter2Loopback').value = routerId2;
                }

                // Initialize OSPF interface inputs
                updateOspfInterfaceInputs();
            } else {
                ospfSection.style.display = 'none';
            }
        }

        function updateOspfInterfaceInputs() {
            const mode = document.querySelector('input[name="ospfInterfaceMode"]:checked').value;
            const container = document.getElementById('ospfInterfaceInputs');
            let html = '';

            if (mode === 'physical') {
                html = `
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            <label class="form-label">Router 1 Interface *</label>
                            <input type="text" class="form-control" id="ospfRouter1Interface"
                                   placeholder="GigabitEthernet0/0/10" required>
                            <div class="form-text">Physical interface on router 1</div>
                        </div>
                        <div class="col-md-6 mb-3">
                            <label class="form-label">Router 1 IP Address *</label>
                            <input type="text" class="form-control" id="ospfRouter1Ip"
                                   placeholder="10.255.255.0" required>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            <label class="form-label">Router 2 Interface *</label>
                            <input type="text" class="form-control" id="ospfRouter2Interface"
                                   placeholder="GigabitEthernet0/0/10" required>
                            <div class="form-text">Physical interface on router 2</div>
                        </div>
                        <div class="col-md-6 mb-3">
                            <label class="form-label">Router 2 IP Address *</label>
                            <input type="text" class="form-control" id="ospfRouter2Ip"
                                   placeholder="10.255.255.1" required>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            <label class="form-label">Subnet Mask *</label>
                            <select class="form-select" id="ospfSubnetMask">
                                <option value="255.255.255.252" selected>/30 (255.255.255.252)</option>
                                <option value="255.255.255.254">/31 (255.255.255.254)</option>
                            </select>
                        </div>
                        <div class="col-md-6 mb-3">
                            <label class="form-label">OSPF Cost (Optional)</label>
                            <input type="number" class="form-control" id="ospfCost"
                                   placeholder="100">
                            <div class="form-text">Leave empty for auto-calculation</div>
                        </div>
                    </div>
                `;
            } else if (mode === 'svi') {
                html = `
                    <div class="row">
                        <div class="col-md-4 mb-3">
                            <label class="form-label">VLAN ID *</label>
                            <input type="number" class="form-control" id="ospfVlanId"
                                   placeholder="999" min="1" max="4094" required>
                            <div class="form-text">VLAN for OSPF interconnect</div>
                        </div>
                        <div class="col-md-4 mb-3">
                            <label class="form-label">Router 1 IP Address *</label>
                            <input type="text" class="form-control" id="ospfRouter1Ip"
                                   placeholder="10.255.255.0" required>
                        </div>
                        <div class="col-md-4 mb-3">
                            <label class="form-label">Router 2 IP Address *</label>
                            <input type="text" class="form-control" id="ospfRouter2Ip"
                                   placeholder="10.255.255.1" required>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            <label class="form-label">Router 1 Physical Trunk Interface *</label>
                            <input type="text" class="form-control" id="ospfRouter1Interface"
                                   placeholder="GigabitEthernet0/0/10" required>
                        </div>
                        <div class="col-md-6 mb-3">
                            <label class="form-label">Router 2 Physical Trunk Interface *</label>
                            <input type="text" class="form-control" id="ospfRouter2Interface"
                                   placeholder="GigabitEthernet0/0/10" required>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            <label class="form-label">Subnet Mask *</label>
                            <select class="form-select" id="ospfSubnetMask">
                                <option value="255.255.255.252" selected>/30 (255.255.255.252)</option>
                                <option value="255.255.255.254">/31 (255.255.255.254)</option>
                            </select>
                        </div>
                        <div class="col-md-6 mb-3">
                            <label class="form-label">OSPF Cost (Optional)</label>
                            <input type="number" class="form-control" id="ospfCost"
                                   placeholder="100">
                        </div>
                    </div>
                `;
            } else if (mode === 'subinterface') {
                html = `
                    <div class="row">
                        <div class="col-md-4 mb-3">
                            <label class="form-label">Subinterface ID *</label>
                            <input type="number" class="form-control" id="ospfVlanId"
                                   placeholder="999" min="1" max="4094" required>
                            <div class="form-text">802.1Q VLAN tag</div>
                        </div>
                        <div class="col-md-4 mb-3">
                            <label class="form-label">Router 1 IP Address *</label>
                            <input type="text" class="form-control" id="ospfRouter1Ip"
                                   placeholder="10.255.255.0" required>
                        </div>
                        <div class="col-md-4 mb-3">
                            <label class="form-label">Router 2 IP Address *</label>
                            <input type="text" class="form-control" id="ospfRouter2Ip"
                                   placeholder="10.255.255.1" required>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            <label class="form-label">Router 1 Parent Interface *</label>
                            <input type="text" class="form-control" id="ospfRouter1Interface"
                                   placeholder="GigabitEthernet0/0/10" required>
                        </div>
                        <div class="col-md-6 mb-3">
                            <label class="form-label">Router 2 Parent Interface *</label>
                            <input type="text" class="form-control" id="ospfRouter2Interface"
                                   placeholder="GigabitEthernet0/0/10" required>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            <label class="form-label">Subnet Mask *</label>
                            <select class="form-select" id="ospfSubnetMask">
                                <option value="255.255.255.252" selected>/30 (255.255.255.252)</option>
                                <option value="255.255.255.254">/31 (255.255.255.254)</option>
                            </select>
                        </div>
                        <div class="col-md-6 mb-3">
                            <label class="form-label">OSPF Cost (Optional)</label>
                            <input type="number" class="form-control" id="ospfCost"
                                   placeholder="100">
                        </div>
                    </div>
                `;
            }

            container.innerHTML = html;

            // Attach validation listeners to the newly created interface fields
            attachOspfInterfaceValidation();
        }

        function toggleOspfAuth() {
            const authType = document.getElementById('ospfAuth').value;
            const authParams = document.getElementById('ospfAuthParams');
            authParams.style.display = authType === 'md5' ? 'block' : 'none';
        }

        function proceedToStep3() {
            const numRouters = parseInt(document.getElementById('numFusionRouters').value);
            fusionRouters = [];

            // Validate and collect fusion router configs
            for (let i = 1; i <= numRouters; i++) {
                const hostname = document.getElementById(`fusionHostname${i}`).value.trim();
                const routerId = document.getElementById(`fusionRouterId${i}`).value.trim();
                const asNumber = document.getElementById(`fusionAsNumber${i}`).value.trim();

                if (!hostname || !routerId || !asNumber) {
                    alert(`Please fill in all required fields for Fusion Router ${i}`);
                    return;
                }

                // Validate IP address format
                const ipRegex = /^(\d{1,3}\.){3}\d{1,3}$/;
                if (!ipRegex.test(routerId)) {
                    alert(`Please enter a valid IP address for Fusion Router ${i} BGP Router ID`);
                    return;
                }

                fusionRouters.push({
                    router_id: i,
                    hostname: hostname,
                    bgp_router_id: routerId,
                    as_number: asNumber
                });
            }

            // Validate AS numbers if iBGP is enabled
            if (numRouters === 2 && document.getElementById('enableIbgp')?.checked) {
                if (fusionRouters[0].as_number !== fusionRouters[1].as_number) {
                    alert('iBGP requires both fusion routers to use the SAME BGP AS number');
                    return;
                }
            }

            showStep(3);
        }

        function getSelectedInterfaceMode() {
            const modes = document.getElementsByName('interfaceMode');
            for (let mode of modes) {
                if (mode.checked) {
                    return mode.value;
                }
            }
            return 'routed';
        }

        function proceedToStep4() {
            currentInterfaceMode = getSelectedInterfaceMode();
            // Initialize with empty connections
            connectionConfigs = {};
            // Render the new table-based interface
            renderBorderNodeTables();
            showStep(4);
        }

        // ============================================
        // UTILITY FUNCTIONS
        // ============================================

        function getMaskBits(subnetMask) {
            // Handle common subnet masks with a lookup table
            const commonMasks = {
                '255.255.255.252': '30',
                '255.255.255.248': '29',
                '255.255.255.240': '28',
                '255.255.255.224': '27',
                '255.255.255.192': '26',
                '255.255.255.128': '25',
                '255.255.255.0': '24',
                '255.255.254.0': '23',
                '255.255.252.0': '22',
                '255.255.248.0': '21',
                '255.255.240.0': '20',
                '255.255.224.0': '19',
                '255.255.192.0': '18',
                '255.255.128.0': '17',
                '255.255.0.0': '16',
                '255.254.0.0': '15',
                '255.252.0.0': '14',
                '255.248.0.0': '13',
                '255.240.0.0': '12',
                '255.224.0.0': '11',
                '255.192.0.0': '10',
                '255.128.0.0': '9',
                '255.0.0.0': '8'
            };

            // Return from lookup table if found
            if (commonMasks[subnetMask]) {
                return commonMasks[subnetMask];
            }

            // Otherwise, calculate by counting bits
            const maskParts = subnetMask.split('.');
            let bits = 0;
            for (let part of maskParts) {
                const num = parseInt(part);
                bits += (num.toString(2).match(/1/g) || []).length;
            }
            return bits.toString();
        }

        // ============================================
        // NEW: TABLE-BASED MAPPING INTERFACE
        // ============================================

        function renderBorderNodeTables() {
            const container = document.getElementById('borderNodeTablesContainer');
            if (!container) {
                console.error('Border node tables container not found');
                return;
            }

            let html = '';

            // Create one table per border node
            borderNodeConfigs.forEach((borderNode, bnIdx) => {
                const loopbackMatch = borderNode.raw_config?.match(/interface Loopback0\s+ip address ([0-9.]+)/);
                const loopbackIp = loopbackMatch ? loopbackMatch[1] : 'N/A';

                html += `
                    <div class="border-node-section-table">
                        <div class="border-node-header-table">
                            <i class="fas fa-server"></i> Border Node: ${borderNode.hostname}
                            <span class="badge bg-light text-dark ms-2">${loopbackIp}</span>
                            <span class="badge bg-secondary ms-2">${borderNode.vlan_interfaces.length} VLAN Interfaces</span>
                        </div>
                        <div class="table-responsive">
                            <table class="table table-hover table-bordered mapping-table">
                                <thead>
                                    <tr>
                                        <th style="width: 15%;">Border Interface</th>
                                        <th style="width: 10%;">VLAN</th>
                                        <th style="width: 15%;">IP Address</th>
                                        <th style="width: 10%;">VRF</th>
                                        <th style="width: 20%;">Fusion Router</th>
                                        <th style="width: 20%;">Fusion Interface</th>
                                        <th style="width: 10%;">Actions</th>
                                    </tr>
                                </thead>
                                <tbody id="borderTable_${bnIdx}">
                `;

                borderNode.vlan_interfaces.forEach((vlan, vIdx) => {
                    const rowId = `row_${bnIdx}_${vIdx}`;
                    const connectionKey = `${borderNode.hostname}_${vlan.vlan}`;
                    const existingConfig = findConnectionConfig(borderNode.hostname, vlan.vlan);
                    const isConfigured = existingConfig !== null;

                    html += `
                        <tr id="${rowId}" class="${isConfigured ? 'mapping-row-configured' : ''}">
                            <td>Vlan${vlan.vlan}</td>
                            <td>${vlan.vlan}</td>
                            <td>${vlan.ip_address}/${getMaskBits(vlan.subnet_mask)}</td>
                            <td><span class="badge ${vlan.vrf ? 'bg-info' : 'bg-secondary'}">${vlan.vrf || 'Global'}</span></td>
                            <td>
                                <select class="form-select form-select-sm" id="fusionSelect_${bnIdx}_${vIdx}"
                                        onchange="updateConnectionFromTable(${bnIdx}, ${vIdx})">
                                    <option value="">-- Select Router --</option>
                                    ${fusionRouters.map(router => `
                                        <option value="${router.router_id}"
                                                ${existingConfig && existingConfig.fusion_router_id === router.router_id ? 'selected' : ''}>
                                            ${router.hostname}
                                        </option>
                                    `).join('')}
                                </select>
                            </td>
                            <td>
                                <div id="fusionInterfaceContainer_${bnIdx}_${vIdx}">
                                    <select class="form-select form-select-sm" disabled>
                                        <option>Select router first</option>
                                    </select>
                                </div>
                            </td>
                            <td>
                                <button class="btn btn-sm btn-primary" onclick="configureConnection(${bnIdx}, ${vIdx})"
                                        id="configBtn_${bnIdx}_${vIdx}" ${!isConfigured ? 'disabled' : ''}>
                                    <i class="fas fa-cog"></i>
                                </button>
                                <button class="btn btn-sm btn-danger" onclick="deleteConnectionFromTable(${bnIdx}, ${vIdx})"
                                        id="deleteBtn_${bnIdx}_${vIdx}" ${!isConfigured ? 'disabled' : ''} style="display: ${isConfigured ? 'inline-block' : 'none'};">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </td>
                        </tr>
                    `;
                });

                html += `
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;

            // Initialize interface dropdowns for already configured connections
            borderNodeConfigs.forEach((borderNode, bnIdx) => {
                borderNode.vlan_interfaces.forEach((vlan, vIdx) => {
                    const existingConfig = findConnectionConfig(borderNode.hostname, vlan.vlan);
                    if (existingConfig) {
                        renderFusionInterfaceDropdown(bnIdx, vIdx, existingConfig.fusion_router_id, existingConfig);
                    }
                });
            });
        }

        function findConnectionConfig(borderHostname, vlan) {
            for (const key in connectionConfigs) {
                const config = connectionConfigs[key];
                if (config.border_hostname === borderHostname && config.border_vlan_id === vlan) {
                    return config;
                }
            }
            return null;
        }

        function updateConnectionFromTable(borderNodeIdx, vlanIdx) {
            const borderNode = borderNodeConfigs[borderNodeIdx];
            const vlan = borderNode.vlan_interfaces[vlanIdx];

            const fusionSelect = document.getElementById(`fusionSelect_${borderNodeIdx}_${vlanIdx}`);
            const selectedRouterId = parseInt(fusionSelect.value);

            if (!selectedRouterId) {
                // Clear selection - remove interface dropdown
                const interfaceContainer = document.getElementById(`fusionInterfaceContainer_${borderNodeIdx}_${vlanIdx}`);
                interfaceContainer.innerHTML = `
                    <select class="form-select form-select-sm" disabled>
                        <option>Select router first</option>
                    </select>
                `;
                // Disable config button
                document.getElementById(`configBtn_${borderNodeIdx}_${vlanIdx}`).disabled = true;
                // Remove connection if exists
                deleteConnectionFromTable(borderNodeIdx, vlanIdx);
                return;
            }

            // Render fusion interface dropdown
            renderFusionInterfaceDropdown(borderNodeIdx, vlanIdx, selectedRouterId);
        }

        function renderFusionInterfaceDropdown(borderNodeIdx, vlanIdx, fusionRouterId, existingConfig = null) {
            const borderNode = borderNodeConfigs[borderNodeIdx];
            const vlan = borderNode.vlan_interfaces[vlanIdx];
            const interfaceContainer = document.getElementById(`fusionInterfaceContainer_${borderNodeIdx}_${vlanIdx}`);

            // Get placeholder text based on interface mode
            let placeholderText = '';
            let existingValue = '';

            if (currentInterfaceMode === 'routed') {
                placeholderText = 'e.g., GigabitEthernet0/0/0';
                if (existingConfig) {
                    existingValue = existingConfig.interface_name || '';
                }
            } else if (currentInterfaceMode === 'svi') {
                placeholderText = 'e.g., Vlan10';
                if (existingConfig && existingConfig.vlan_id) {
                    existingValue = `Vlan${existingConfig.vlan_id}`;
                }
            } else if (currentInterfaceMode === 'subinterface') {
                placeholderText = 'e.g., GigabitEthernet0/0/0.10';
                if (existingConfig && existingConfig.interface_name && existingConfig.subif_id) {
                    existingValue = `${existingConfig.interface_name}.${existingConfig.subif_id}`;
                }
            }

            interfaceContainer.innerHTML = `
                <input type="text" class="form-control form-control-sm" id="fusionInterface_${borderNodeIdx}_${vlanIdx}"
                       placeholder="${placeholderText}"
                       value="${existingValue}"
                       onblur="handleInterfaceSelection(${borderNodeIdx}, ${vlanIdx}, ${fusionRouterId})"
                       onkeypress="if(event.key === 'Enter') { this.blur(); }">
            `;

            // If there's an existing configuration, trigger interface selection
            if (existingConfig) {
                handleInterfaceSelection(borderNodeIdx, vlanIdx, fusionRouterId);
            }
        }

        function handleInterfaceSelection(borderNodeIdx, vlanIdx, fusionRouterId) {
            const borderNode = borderNodeConfigs[borderNodeIdx];
            const vlan = borderNode.vlan_interfaces[vlanIdx];
            const interfaceInput = document.getElementById(`fusionInterface_${borderNodeIdx}_${vlanIdx}`);
            const selectedInterface = interfaceInput.value.trim();

            if (!selectedInterface) {
                // Disable config button if no interface selected
                document.getElementById(`configBtn_${borderNodeIdx}_${vlanIdx}`).disabled = true;
                return;
            }

            // Enable config button
            document.getElementById(`configBtn_${borderNodeIdx}_${vlanIdx}`).disabled = false;

            // Create or update connection configuration
            const connectionKey = `${borderNode.hostname}_${vlan.vlan}_${fusionRouterId}`;

            // Calculate peer IP for Fusion router
            const peerIp = calculateFusionIP(vlan.ip_address);

            // Create basic configuration
            const config = {
                border_hostname: borderNode.hostname,
                border_vlan_id: vlan.vlan,
                border_ip: vlan.ip_address,
                border_subnet_mask: vlan.subnet_mask,
                border_vrf: vlan.vrf || '',
                fusion_router_id: fusionRouterId,
                fusion_ip: peerIp,
                interface_mode: currentInterfaceMode
            };

            // Add mode-specific fields based on interface mode and user input
            if (currentInterfaceMode === 'routed') {
                config.interface_name = selectedInterface;
            } else if (currentInterfaceMode === 'svi') {
                // Extract VLAN ID from input (e.g., "Vlan10" -> 10)
                const vlanMatch = selectedInterface.match(/Vlan(\d+)/i);
                if (vlanMatch) {
                    config.vlan_id = parseInt(vlanMatch[1]);
                } else {
                    // If user just typed a number, assume it's the VLAN ID
                    const numericVlan = parseInt(selectedInterface);
                    config.vlan_id = isNaN(numericVlan) ? 10 : numericVlan;
                }
                config.physical_interface = 'GigabitEthernet0/0/0'; // Default
            } else if (currentInterfaceMode === 'subinterface') {
                // Parse subinterface (e.g., "GigabitEthernet0/0/0.10")
                const parts = selectedInterface.split('.');
                if (parts.length === 2) {
                    config.interface_name = parts[0];
                    config.subif_id = parseInt(parts[1]);
                } else {
                    // Invalid format, use as-is for routed interface
                    config.interface_name = selectedInterface;
                }
            }

            // Store in connectionConfigs
            connectionConfigs[connectionKey] = config;

            // Update row styling
            const row = document.getElementById(`row_${borderNodeIdx}_${vlanIdx}`);
            row.classList.add('mapping-row-configured');

            // Show delete button
            const deleteBtn = document.getElementById(`deleteBtn_${borderNodeIdx}_${vlanIdx}`);
            deleteBtn.style.display = 'inline-block';
            deleteBtn.disabled = false;

            console.log('Connection created:', config);
        }

        function configureConnection(borderNodeIdx, vlanIdx) {
            const borderNode = borderNodeConfigs[borderNodeIdx];
            const vlan = borderNode.vlan_interfaces[vlanIdx];
            const existingConfig = findConnectionConfig(borderNode.hostname, vlan.vlan);

            if (!existingConfig) {
                alert('Please select a Fusion router and interface first.');
                return;
            }

            // Store current connection for modal
            currentConnection = existingConfig;

            // Open the existing connection modal for detailed configuration
            openConnectionModal(borderNode.hostname, vlan.vlan, vlan.ip_address, vlan.vrf, vlan.subnet_mask);
        }

        function deleteConnectionFromTable(borderNodeIdx, vlanIdx) {
            const borderNode = borderNodeConfigs[borderNodeIdx];
            const vlan = borderNode.vlan_interfaces[vlanIdx];

            // Find and delete the connection
            for (const key in connectionConfigs) {
                const config = connectionConfigs[key];
                if (config.border_hostname === borderNode.hostname && config.border_vlan_id === vlan.vlan) {
                    delete connectionConfigs[key];
                    break;
                }
            }

            // Reset row styling
            const row = document.getElementById(`row_${borderNodeIdx}_${vlanIdx}`);
            row.classList.remove('mapping-row-configured');

            // Reset dropdowns
            const fusionSelect = document.getElementById(`fusionSelect_${borderNodeIdx}_${vlanIdx}`);
            fusionSelect.value = '';

            const interfaceContainer = document.getElementById(`fusionInterfaceContainer_${borderNodeIdx}_${vlanIdx}`);
            interfaceContainer.innerHTML = `
                <select class="form-select form-select-sm" disabled>
                    <option>Select router first</option>
                </select>
            `;

            // Disable buttons
            document.getElementById(`configBtn_${borderNodeIdx}_${vlanIdx}`).disabled = true;
            const deleteBtn = document.getElementById(`deleteBtn_${borderNodeIdx}_${vlanIdx}`);
            deleteBtn.style.display = 'none';
            deleteBtn.disabled = true;
        }

        // ============================================
        // VIS.JS NETWORK TOPOLOGY PREVIEW
        // ============================================

        function previewTopology() {
            const modalElement = document.getElementById('topologyPreviewModal');
            const modal = new bootstrap.Modal(modalElement);

            // Attach event listener before showing modal
            modalElement.addEventListener('shown.bs.modal', function () {
                try {
                    renderVisJsTopology();
                } catch (error) {
                    console.error('Error rendering topology:', error);
                    alert('Failed to render network diagram. Please check the console for details.');
                }
            }, { once: true });

            modal.show();
        }

        function renderVisJsTopology() {
            const container = document.getElementById('networkDiagram');

            // Clear any existing content
            container.innerHTML = '';

            // Check if vis is loaded
            if (typeof vis === 'undefined') {
                console.error('vis.js library not loaded');
                container.innerHTML = '<div style="padding: 20px; text-align: center;">Error: Visualization library not loaded. Please refresh the page.</div>';
                return;
            }

            // Create nodes array
            const nodesArray = [];
            const edgesArray = [];

            // Check if there's any data to display
            if (!fusionRouters || fusionRouters.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">No fusion routers configured yet. Please add at least one fusion router.</div>';
                return;
            }

            if (!borderNodeConfigs || borderNodeConfigs.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">No border nodes configured yet. Please upload border node configurations.</div>';
                return;
            }

            // Add Fusion routers as nodes
            fusionRouters.forEach(router => {
                if (router && router.router_id && router.hostname) {
                    nodesArray.push({
                        id: `fusion_${router.router_id}`,
                        label: router.hostname,
                        shape: 'box',
                        color: {
                            border: '#667eea',
                            background: '#e8eaf6',
                            highlight: {
                                border: '#5568d3',
                                background: '#c5cae9'
                            }
                        },
                        font: { size: 16, face: 'Arial', bold: true },
                        margin: 10,
                        widthConstraint: { minimum: 150, maximum: 200 }
                    });
                }
            });

            // Add Border nodes as nodes
            borderNodeConfigs.forEach((borderNode, idx) => {
                if (borderNode && borderNode.hostname) {
                    nodesArray.push({
                        id: `border_${idx}`,
                        label: borderNode.hostname,
                        shape: 'ellipse',
                        color: {
                            border: '#764ba2',
                            background: '#f3e5f5',
                            highlight: {
                                border: '#653a8a',
                                background: '#e1bee7'
                            }
                        },
                        font: { size: 16, face: 'Arial', bold: true },
                        margin: 10
                    });
                }
            });

            // Add connections as edges
            if (connectionConfigs && Object.keys(connectionConfigs).length > 0) {
                Object.keys(connectionConfigs).forEach(key => {
                    const config = connectionConfigs[key];
                    if (!config || !config.border_hostname || !config.fusion_router_id) {
                        return; // Skip invalid configs
                    }

                    const borderIdx = borderNodeConfigs.findIndex(bn => bn.hostname === config.border_hostname);
                    if (borderIdx === -1) {
                        return; // Skip if border node not found
                    }

                    let fusionInterfaceLabel = '';
                    if (config.interface_mode === 'routed') {
                        fusionInterfaceLabel = config.interface_name || '';
                    } else if (config.interface_mode === 'svi') {
                        fusionInterfaceLabel = `Vlan${config.vlan_id}`;
                    } else if (config.interface_mode === 'subinterface') {
                        fusionInterfaceLabel = `${config.interface_name}.${config.subif_id}`;
                    }

                    const edgeLabel = `VLAN ${config.border_vlan_id}\\n${config.border_ip} -> ${config.fusion_ip}\\n${fusionInterfaceLabel}`;

                    edgesArray.push({
                        from: `border_${borderIdx}`,
                        to: `fusion_${config.fusion_router_id}`,
                        label: edgeLabel,
                        arrows: 'to',
                        color: { color: '#667eea', highlight: '#5568d3' },
                        font: { size: 11, align: 'middle', background: 'white' },
                        smooth: { type: 'cubicBezier' }
                    });
                });
            }

            // Create vis.js network
            const nodes = new vis.DataSet(nodesArray);
            const edges = new vis.DataSet(edgesArray);

            const data = {
                nodes: nodes,
                edges: edges
            };

            const options = {
                layout: {
                    hierarchical: {
                        direction: 'LR',
                        sortMethod: 'directed',
                        levelSeparation: 300,
                        nodeSpacing: 150
                    }
                },
                physics: {
                    enabled: false
                },
                edges: {
                    smooth: {
                        type: 'cubicBezier',
                        forceDirection: 'horizontal',
                        roundness: 0.4
                    },
                    width: 2
                },
                interaction: {
                    dragNodes: true,
                    dragView: true,
                    zoomView: true
                }
            };

            // Create the network visualization
            try {
                const network = new vis.Network(container, data, options);
                console.log('Network diagram rendered successfully');
            } catch (error) {
                console.error('Error creating vis.Network:', error);
                container.innerHTML = '<div style="padding: 20px; text-align: center;">Error rendering network diagram. Please try again.</div>';
            }
        }

        // ============================================
        // ARCHIVED: OLD SVG-BASED TOPOLOGY FUNCTIONS
        // (Kept for reference, not called in new design)
        // ============================================

        /*
        function initializeTopologyDiagram() {
            connectionConfigs = {};
            zoomLevel = 1.0;
            panX = 0;
            panY = 0;

            if (fusionRouters.length === 1) {
                currentFusionRouterView = fusionRouters[0].router_id;
            } else {
                currentFusionRouterView = null;
            }

            renderRouterViewSelector();
            renderSidebarInterfaces();
            renderTopologyDiagram();
            initializePanZoom();
        }
        */

        // ============================================
        // ARCHIVED: OLD SVG-BASED RENDERING FUNCTIONS
        // These functions are kept for reference but are no longer used
        // The new table-based interface uses renderBorderNodeTables() instead
        // ============================================

        /*
        function renderRouterViewSelector() {
            const selector = document.getElementById('routerViewSelector');
            const buttonsContainer = document.getElementById('routerViewButtons');

            // Safety check: ensure elements exist
            if (!selector || !buttonsContainer) {
                console.warn('Router view selector elements not found in DOM');
                return;
            }

            if (fusionRouters.length <= 1) {
                selector.style.display = 'none';
                return;
            }

            selector.style.display = 'block';
            let html = '';

            // "All Routers" button
            html += `
                <button type="button" class="btn ${currentFusionRouterView === null ? 'btn-primary' : 'btn-outline-secondary'}"
                        onclick="switchRouterView(null)">
                    <i class="fas fa-th"></i> All Routers
                </button>
            `;

            // Individual router buttons
            fusionRouters.forEach(router => {
                const isActive = currentFusionRouterView === router.router_id;
                html += `
                    <button type="button" class="btn ${isActive ? 'btn-primary' : 'btn-outline-secondary'}"
                            onclick="switchRouterView(${router.router_id})">
                        <i class="fas fa-server"></i> ${router.hostname}
                    </button>
                `;
            });

            buttonsContainer.innerHTML = html;
        }

        function switchRouterView(routerId) {
            currentFusionRouterView = routerId;
            renderRouterViewSelector();
            renderTopologyDiagram();
            resetZoom(); // Reset zoom when switching views
        }

        function renderSidebarInterfaces() {
            const container = document.getElementById('borderNodesList');

            // Safety check: ensure container exists
            if (!container) {
                console.warn('Border nodes list container not found in DOM');
                return;
            }

            let html = '';

            borderNodeConfigs.forEach((borderNode, idx) => {
                const sectionId = `border-section-${idx}`;
                html += `
                    <div class="border-node-section">
                        <div class="border-node-header" onclick="toggleBorderSection('${sectionId}')">
                            <span><i class="fas fa-server"></i> ${borderNode.hostname}</span>
                            <i class="fas fa-chevron-down toggle-icon"></i>
                        </div>
                        <div class="interface-list" id="${sectionId}">
                `;

                borderNode.vlan_interfaces.forEach((vlan, vIdx) => {
                    const interfaceKey = `${borderNode.hostname}_${vlan.vlan}`;
                    const isConfigured = isInterfaceConfigured(borderNode.hostname, vlan.vlan);
                    const vrfClass = vlan.vrf ? 'vrf' : 'global';
                    const vrfText = vlan.vrf || 'Global Table';

                    html += `
                        <div class="interface-item ${isConfigured ? 'configured' : ''}"
                             draggable="true"
                             data-border-hostname="${borderNode.hostname}"
                             data-vlan="${vlan.vlan}"
                             data-ip="${vlan.ip_address}"
                             data-vrf="${vlan.vrf || ''}"
                             data-subnet-mask="${vlan.subnet_mask}"
                             ondragstart="handleInterfaceDragStart(event)"
                             ondragend="handleInterfaceDragEnd(event)">
                            <div class="interface-vlan">VLAN ${vlan.vlan}</div>
                            <div class="interface-ip">${vlan.ip_address}/${getMaskBits(vlan.subnet_mask)}</div>
                            <span class="interface-vrf ${vrfClass}">${vrfText}</span>
                        </div>
                    `;
                });

                html += `
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function isInterfaceConfigured(borderHostname, vlan) {
            // Check if any connection exists for this border hostname + vlan
            for (const key in connectionConfigs) {
                const config = connectionConfigs[key];
                if (config.border_hostname === borderHostname && config.border_vlan_id === vlan) {
                    return true;
                }
            }
            return false;
        }

        function toggleBorderSection(sectionId) {
            const section = document.getElementById(sectionId);
            const header = section.previousElementSibling;

            if (section.style.display === 'none') {
                section.style.display = 'block';
                header.classList.remove('collapsed');
            } else {
                section.style.display = 'none';
                header.classList.add('collapsed');
            }
        }

        function filterInterfaces() {
            const searchTerm = document.getElementById('interfaceSearch').value.toLowerCase();
            const interfaceItems = document.querySelectorAll('.interface-item');

            interfaceItems.forEach(item => {
                const vlan = item.dataset.vlan;
                const ip = item.dataset.ip;
                const vrf = item.dataset.vrf;
                const text = `vlan${vlan} ${ip} ${vrf}`.toLowerCase();

                if (text.includes(searchTerm)) {
                    item.style.display = 'block';
                } else {
                    item.style.display = 'none';
                }
            });
        }

        function renderTopologyDiagram() {
            const container = document.getElementById('topologyContainer');

            // Safety check: ensure container exists
            if (!container) {
                console.error('Topology container not found in DOM');
                return;
            }

            container.innerHTML = '';

            // Enhanced dimensions for more detail
            const width = 2000;
            const height = 1200;
            const margin = { left: 280, right: 280, top: 120, bottom: 120 };

            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('id', 'topologySvg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

            // Create main group for pan/zoom transformations
            const mainGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            mainGroup.setAttribute('id', 'mainGroup');
            svg.appendChild(mainGroup);

            // Calculate positions - increased device sizes for better visibility
            const fusionX = margin.left;
            const borderX = width - margin.right;
            const deviceWidth = 200;
            const deviceHeight = 100;

            // Filter fusion routers based on current view
            const visibleFusionRouters = currentFusionRouterView === null
                ? fusionRouters
                : fusionRouters.filter(r => r.router_id === currentFusionRouterView);

            // Filter connections based on current view
            const visibleConnectionConfigs = currentFusionRouterView === null
                ? connectionConfigs
                : Object.fromEntries(
                    Object.entries(connectionConfigs).filter(([key, config]) =>
                        config.fusion_router_id === currentFusionRouterView
                    )
                );

            // Get unique border nodes that have connections in current view
            const borderNodesWithConnections = new Set();
            Object.values(visibleConnectionConfigs).forEach(config => {
                borderNodesWithConnections.add(config.border_hostname);
            });

            // Show all border nodes if viewing all routers, otherwise filter
            const visibleBorderNodes = currentFusionRouterView === null
                ? borderNodeConfigs
                : borderNodeConfigs.filter(node => borderNodesWithConnections.has(node.hostname));

            const fusionCount = visibleFusionRouters.length;
            const borderCount = visibleBorderNodes.length > 0 ? visibleBorderNodes.length : borderNodeConfigs.length;

            const fusionSpacing = (height - margin.top - margin.bottom) / (fusionCount + 1);
            const borderSpacing = (height - margin.top - margin.bottom) / (borderCount + 1);

            // Draw connection lines layer
            const connectionsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            connectionsGroup.setAttribute('id', 'connectionsGroup');
            mainGroup.appendChild(connectionsGroup);

            // Draw existing connections (filtered)
            Object.keys(visibleConnectionConfigs).forEach(connectionKey => {
                const config = visibleConnectionConfigs[connectionKey];
                drawConnection(connectionsGroup, config, fusionSpacing, borderSpacing, margin, deviceWidth, deviceHeight, width, visibleFusionRouters, visibleBorderNodes);
            });

            // Draw fusion routers (filtered)
            fusionRouterPositions = {};
            visibleFusionRouters.forEach((router, idx) => {
                const y = margin.top + fusionSpacing * (idx + 1) - deviceHeight / 2;
                const cx = fusionX + deviceWidth / 2;
                const cy = y + deviceHeight / 2;

                fusionRouterPositions[router.router_id] = { x: cx, y: cy, width: deviceWidth, height: deviceHeight };

                const group = drawDevice(mainGroup, fusionX, y, deviceWidth, deviceHeight, router.hostname, 'Fusion Router', router.router_id);
                svg.appendChild(group);
            });

            // Draw border nodes (all of them for context, even in filtered view)
            const nodesToDraw = visibleBorderNodes.length > 0 ? visibleBorderNodes : borderNodeConfigs;
            nodesToDraw.forEach((node, idx) => {
                const y = margin.top + borderSpacing * (idx + 1) - deviceHeight / 2;
                const group = drawDevice(mainGroup, borderX - deviceWidth, y, deviceWidth, deviceHeight, node.hostname, 'Border Node', null, node);
                svg.appendChild(group);

                // Draw VLAN interface list to the right of border node
                if (node.vlan_interfaces && node.vlan_interfaces.length > 0) {
                    drawBorderVlanList(mainGroup, borderX + 10, y, node.vlan_interfaces, deviceHeight);
                }
            });

            // Add ghost line for drag preview
            const ghostLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            ghostLine.setAttribute('id', 'dragGhostLine');
            ghostLine.setAttribute('x1', '0');
            ghostLine.setAttribute('y1', '0');
            ghostLine.setAttribute('x2', '0');
            ghostLine.setAttribute('y2', '0');
            ghostLine.style.display = 'none';
            mainGroup.appendChild(ghostLine);

            container.appendChild(svg);
            updateZoomTransform();
        }

        /**
         * Draw VLAN interface list next to border node
         * Shows compact list of VLANs with their IPs
         */
        function drawBorderVlanList(parentGroup, x, y, vlanInterfaces, deviceHeight) {
            const listGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            listGroup.setAttribute('class', 'vlan-list-group');

            // Calculate dimensions
            const lineHeight = 12;
            const maxVisible = 5; // Show max 5 VLANs, then indicate "..."
            const vlansToShow = vlanInterfaces.slice(0, maxVisible);
            const hasMore = vlanInterfaces.length > maxVisible;
            const totalHeight = (vlansToShow.length + (hasMore ? 1 : 0)) * lineHeight + 8;
            const listWidth = 120;

            // Background
            const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            bg.setAttribute('x', x);
            bg.setAttribute('y', y);
            bg.setAttribute('width', listWidth);
            bg.setAttribute('height', totalHeight);
            bg.setAttribute('fill', '#f8f9fa');
            bg.setAttribute('stroke', '#dee2e6');
            bg.setAttribute('stroke-width', '1');
            bg.setAttribute('rx', '4');
            bg.setAttribute('opacity', '0.95');
            listGroup.appendChild(bg);

            // Title
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            title.setAttribute('x', x + listWidth / 2);
            title.setAttribute('y', y + 10);
            title.setAttribute('class', 'border-interface-label');
            title.setAttribute('font-size', '8');
            title.textContent = 'VLANs';
            listGroup.appendChild(title);

            // VLAN entries
            vlansToShow.forEach((vlanIf, idx) => {
                const entryY = y + 18 + (idx * lineHeight);

                const vlanText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                vlanText.setAttribute('x', x + 5);
                vlanText.setAttribute('y', entryY);
                vlanText.setAttribute('class', 'border-interface-list');
                vlanText.setAttribute('font-weight', '600');
                vlanText.textContent = `${vlanIf.vlan}:`;
                listGroup.appendChild(vlanText);

                const ipText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                ipText.setAttribute('x', x + 28);
                ipText.setAttribute('y', entryY);
                ipText.setAttribute('class', 'border-interface-list');
                ipText.setAttribute('font-size', '7');
                ipText.textContent = vlanIf.ip_address;
                listGroup.appendChild(ipText);
            });

            // Show "..." if more VLANs exist
            if (hasMore) {
                const moreText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                moreText.setAttribute('x', x + listWidth / 2);
                moreText.setAttribute('y', y + 18 + (vlansToShow.length * lineHeight));
                moreText.setAttribute('class', 'border-interface-list');
                moreText.setAttribute('text-anchor', 'middle');
                moreText.setAttribute('font-style', 'italic');
                moreText.textContent = `+${vlanInterfaces.length - maxVisible} more...`;
                listGroup.appendChild(moreText);
            }

            parentGroup.appendChild(listGroup);
        }

        function drawDevice(parentGroup, x, y, width, height, label, type, fusionRouterId, borderNodeData) {
            const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            group.setAttribute('class', `device-node ${type === 'Fusion Router' ? 'fusion-router' : ''}`);

            if (fusionRouterId) {
                group.setAttribute('data-fusion-router-id', fusionRouterId);
            }

            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('x', x);
            rect.setAttribute('y', y);
            rect.setAttribute('width', width);
            rect.setAttribute('height', height);
            rect.setAttribute('class', 'device-rect');
            group.appendChild(rect);

            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', x + width / 2);
            text.setAttribute('y', y + height / 2 - 10);
            text.setAttribute('class', 'device-label');
            text.textContent = label;
            group.appendChild(text);

            const typeText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            typeText.setAttribute('x', x + width / 2);
            typeText.setAttribute('y', y + height / 2 + 5);
            typeText.setAttribute('class', 'device-type');
            typeText.textContent = type;
            group.appendChild(typeText);

            // Add interface information for border nodes
            if (type === 'Border Node' && borderNodeData && borderNodeData.vlan_interfaces) {
                const vlanCount = borderNodeData.vlan_interfaces.length;
                const interfaceText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                interfaceText.setAttribute('x', x + width / 2);
                interfaceText.setAttribute('y', y + height / 2 + 18);
                interfaceText.setAttribute('class', 'border-interface-label');
                interfaceText.textContent = `${vlanCount} VLAN${vlanCount !== 1 ? 's' : ''}`;
                group.appendChild(interfaceText);
            }

            // Add configured interface count for fusion routers
            if (type === 'Fusion Router' && fusionRouterId) {
                const configuredCount = Object.values(connectionConfigs).filter(
                    c => c.fusion_router_id === fusionRouterId
                ).length;
                if (configuredCount > 0) {
                    const interfaceText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    interfaceText.setAttribute('x', x + width / 2);
                    interfaceText.setAttribute('y', y + height / 2 + 18);
                    interfaceText.setAttribute('class', 'border-interface-label');
                    interfaceText.textContent = `${configuredCount} connection${configuredCount !== 1 ? 's' : ''}`;
                    group.appendChild(interfaceText);
                }
            }

            parentGroup.appendChild(group);
            return group;
        }

        /**
         * Format fusion router interface label based on interface mode
         * Returns abbreviated interface name for display on diagram
         */
        function formatInterfaceLabel(config) {
            if (config.interface_mode === 'routed' && config.interface_name) {
                // Abbreviate interface names: GigabitEthernet -> Gi, TenGigabitEthernet -> Te, etc.
                return config.interface_name
                    .replace('GigabitEthernet', 'Gi')
                    .replace('TenGigabitEthernet', 'Te')
                    .replace('FortyGigabitEthernet', 'Fo')
                    .replace('HundredGigE', 'Hu')
                    .replace('FastEthernet', 'Fa');
            } else if (config.interface_mode === 'svi') {
                if (config.vlan_id && config.physical_interface) {
                    return `Vl${config.vlan_id} (${config.physical_interface.replace('GigabitEthernet', 'Gi')})`;
                } else if (config.vlan_id) {
                    return `Vlan${config.vlan_id}`;
                }
            } else if (config.interface_mode === 'subinterface') {
                if (config.interface_name && config.subif_id) {
                    const abbrev = config.interface_name
                        .replace('GigabitEthernet', 'Gi')
                        .replace('TenGigabitEthernet', 'Te')
                        .replace('FortyGigabitEthernet', 'Fo')
                        .replace('FastEthernet', 'Fa');
                    return `${abbrev}.${config.subif_id}`;
                }
            }
            return null;
        }

        /**
         * Calculate line offset for connections to avoid overlap
         * When multiple VLANs from same border connect to same fusion router,
         * we offset connection points vertically
         */
        function calculateConnectionOffset(config, allConfigs) {
            // Find all connections with same fusion router and border node
            const sameConnections = Object.values(allConfigs).filter(c =>
                c.fusion_router_id === config.fusion_router_id &&
                c.border_hostname === config.border_hostname
            );

            if (sameConnections.length <= 1) return 0;

            // Sort by VLAN ID for consistent ordering
            sameConnections.sort((a, b) => parseInt(a.border_vlan_id) - parseInt(b.border_vlan_id));

            // Find index of current connection
            const currentIndex = sameConnections.findIndex(c =>
                c.border_vlan_id === config.border_vlan_id
            );

            // Calculate offset: spread connections vertically with increased spacing
            // Increased from 15 to 35 pixels for better separation and label clearance
            const offsetSpacing = 35; // pixels between each line
            const totalOffset = (sameConnections.length - 1) * offsetSpacing;
            const startOffset = -totalOffset / 2;

            return startOffset + (currentIndex * offsetSpacing);
        }

        function drawConnection(parentGroup, config, fusionSpacing, borderSpacing, margin, deviceWidth, deviceHeight, canvasWidth, visibleFusionRouters, visibleBorderNodes) {
            const connectionKey = `${config.border_hostname}_${config.border_vlan_id}_${config.fusion_router_id}`;

            // Use visible routers and nodes for index calculation
            const fusionList = visibleFusionRouters || fusionRouters;
            const borderList = visibleBorderNodes || borderNodeConfigs;

            // Find fusion router index
            const fusionIdx = fusionList.findIndex(r => r.router_id === config.fusion_router_id);
            // Find border node index
            const borderIdx = borderList.findIndex(b => b.hostname === config.border_hostname);

            if (fusionIdx === -1 || borderIdx === -1) return;

            // Calculate vertical offset to prevent line overlap
            const yOffset = calculateConnectionOffset(config, connectionConfigs);

            const fusionY = margin.top + fusionSpacing * (fusionIdx + 1) + yOffset;
            const borderY = margin.top + borderSpacing * (borderIdx + 1) + yOffset;

            const x1 = margin.left + deviceWidth;
            const y1 = fusionY;
            const x2 = canvasWidth - margin.right - deviceWidth;
            const y2 = borderY;

            // Create connection group
            const connGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            connGroup.setAttribute('class', 'connection-group');
            connGroup.setAttribute('data-connection-key', connectionKey);

            // Curved path
            const midX = (x1 + x2) / 2;
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const d = `M ${x1} ${y1} C ${midX} ${y1}, ${midX} ${y2}, ${x2} ${y2}`;
            path.setAttribute('d', d);
            path.setAttribute('class', 'connection-path configured');
            path.onclick = function() { editConnection(connectionKey); };
            connGroup.appendChild(path);

            // Connection dots
            const dot1 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            dot1.setAttribute('cx', x1);
            dot1.setAttribute('cy', y1);
            dot1.setAttribute('class', 'connection-dot configured');
            connGroup.appendChild(dot1);

            const dot2 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            dot2.setAttribute('cx', x2);
            dot2.setAttribute('cy', y2);
            dot2.setAttribute('class', 'connection-dot configured');
            connGroup.appendChild(dot2);

            // Label group at midpoint
            const labelX = midX;
            const labelY = (y1 + y2) / 2;

            // VLAN label background
            const labelBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            labelBg.setAttribute('x', labelX - 35);
            labelBg.setAttribute('y', labelY - 18);
            labelBg.setAttribute('width', '70');
            labelBg.setAttribute('height', '36');
            labelBg.setAttribute('class', 'connection-label-bg');
            connGroup.appendChild(labelBg);

            // VLAN text
            const vlanText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            vlanText.setAttribute('x', labelX);
            vlanText.setAttribute('y', labelY - 4);
            vlanText.setAttribute('class', 'connection-label-text');
            vlanText.textContent = `VLAN ${config.border_vlan_id}`;
            connGroup.appendChild(vlanText);

            // VRF badge
            const vrfText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            vrfText.setAttribute('x', labelX);
            vrfText.setAttribute('y', labelY + 10);
            vrfText.setAttribute('class', 'connection-vrf-badge');
            vrfText.textContent = config.vrf_name || 'N/A';
            vrfText.setAttribute('fill', '#764ba2');
            connGroup.appendChild(vrfText);

            // Add fusion router interface label (left side of connection)
            // Positioned further from connection point to avoid overlap
            const fusionInterfaceLabel = formatInterfaceLabel(config);
            if (fusionInterfaceLabel) {
                const fusionIfBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                const labelWidth = fusionInterfaceLabel.length * 6.5 + 12;
                const labelHeight = 20;
                const labelOffsetX = 15; // Increased horizontal offset for better spacing
                const labelOffsetY = -22; // Increased vertical offset above connection

                fusionIfBg.setAttribute('x', x1 + labelOffsetX);
                fusionIfBg.setAttribute('y', y1 + labelOffsetY);
                fusionIfBg.setAttribute('width', labelWidth);
                fusionIfBg.setAttribute('height', labelHeight);
                fusionIfBg.setAttribute('class', 'interface-label-bg');
                connGroup.appendChild(fusionIfBg);

                const fusionIfText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                fusionIfText.setAttribute('x', x1 + labelOffsetX + labelWidth / 2);
                fusionIfText.setAttribute('y', y1 + labelOffsetY + 13);
                fusionIfText.setAttribute('class', 'interface-label');
                fusionIfText.textContent = fusionInterfaceLabel;
                connGroup.appendChild(fusionIfText);
            }

            // Add border VLAN interface label (right side of connection)
            // Positioned further from connection point to avoid overlap
            const borderIfBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            const borderLabel = `VLAN ${config.border_vlan_id}`;
            const borderLabelWidth = borderLabel.length * 6.5 + 12;
            const labelHeight = 20;
            const labelOffsetX = 15; // Increased horizontal offset for better spacing
            const labelOffsetY = -22; // Increased vertical offset above connection

            borderIfBg.setAttribute('x', x2 - borderLabelWidth - labelOffsetX);
            borderIfBg.setAttribute('y', y2 + labelOffsetY);
            borderIfBg.setAttribute('width', borderLabelWidth);
            borderIfBg.setAttribute('height', labelHeight);
            borderIfBg.setAttribute('class', 'interface-label-bg');
            connGroup.appendChild(borderIfBg);

            const borderIfText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            borderIfText.setAttribute('x', x2 - borderLabelWidth / 2 - labelOffsetX);
            borderIfText.setAttribute('y', y2 + labelOffsetY + 13);
            borderIfText.setAttribute('class', 'interface-port-label');
            borderIfText.textContent = borderLabel;
            connGroup.appendChild(borderIfText);

            // Delete button
            const deleteBtn = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            deleteBtn.setAttribute('class', 'connection-delete-btn');
            deleteBtn.onclick = function(e) {
                e.stopPropagation();
                deleteConnection(connectionKey);
            };

            const deleteCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            deleteCircle.setAttribute('cx', labelX + 40);
            deleteCircle.setAttribute('cy', labelY - 10);
            deleteCircle.setAttribute('r', '10');
            deleteCircle.setAttribute('class', 'connection-delete-circle');
            deleteBtn.appendChild(deleteCircle);

            const deleteIcon = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            deleteIcon.setAttribute('x', labelX + 40);
            deleteIcon.setAttribute('y', labelY - 6);
            deleteIcon.setAttribute('class', 'connection-delete-icon');
            deleteIcon.textContent = '\u00D7';
            deleteBtn.appendChild(deleteIcon);

            connGroup.appendChild(deleteBtn);
            parentGroup.appendChild(connGroup);
        }

        // ============================================
        // DRAG AND DROP FUNCTIONALITY
        // ============================================

        function handleInterfaceDragStart(event) {
            isDragging = true;
            const item = event.target;
            item.classList.add('dragging');

            currentDragData = {
                borderHostname: item.dataset.borderHostname,
                vlan: item.dataset.vlan,
                ip: item.dataset.ip,
                vrf: item.dataset.vrf,
                subnetMask: item.dataset.subnetMask
            };

            event.dataTransfer.effectAllowed = 'move';
            event.dataTransfer.setData('text/plain', JSON.stringify(currentDragData));

            // Setup drop zones
            document.querySelectorAll('.device-node.fusion-router').forEach(node => {
                node.addEventListener('dragover', handleDragOver);
                node.addEventListener('drop', handleDrop);
                node.addEventListener('dragleave', handleDragLeave);
            });

            // Setup SVG drag tracking for ghost line
            const svg = document.getElementById('topologySvg');
            svg.addEventListener('mousemove', updateGhostLine);
        }

        function handleInterfaceDragEnd(event) {
            isDragging = false;
            event.target.classList.remove('dragging');

            // Hide ghost line
            const ghostLine = document.getElementById('dragGhostLine');
            if (ghostLine) {
                ghostLine.style.display = 'none';
            }

            // Remove drop zone listeners
            document.querySelectorAll('.device-node.fusion-router').forEach(node => {
                node.removeEventListener('dragover', handleDragOver);
                node.removeEventListener('drop', handleDrop);
                node.removeEventListener('dragleave', handleDragLeave);
                node.classList.remove('drag-over');
            });

            const svg = document.getElementById('topologySvg');
            if (svg) {
                svg.removeEventListener('mousemove', updateGhostLine);
            }

            currentDragData = null;
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            this.classList.add('drag-over');
        }

        function handleDragLeave(event) {
            this.classList.remove('drag-over');
        }

        function handleDrop(event) {
            event.preventDefault();
            this.classList.remove('drag-over');

            if (!currentDragData) return;

            const fusionRouterId = parseInt(this.dataset.fusionRouterId);
            const fusionRouter = fusionRouters.find(r => r.router_id === fusionRouterId);

            if (!fusionRouter) return;

            // If viewing a specific router, only allow drops on that router
            if (currentFusionRouterView !== null && fusionRouterId !== currentFusionRouterView) {
                alert(`This connection can only be added in the "${fusionRouter.hostname}" view. Please switch to that router's diagram.`);
                return;
            }

            // Create connection key
            const connectionKey = `${currentDragData.borderHostname}_${currentDragData.vlan}_${fusionRouterId}`;

            // Check if already configured
            if (connectionConfigs[connectionKey]) {
                alert('This connection is already configured. Click on the connection line to edit it.');
                return;
            }

            // Calculate fusion IP
            const fusionIp = calculateFusionIP(currentDragData.ip);

            // Prepare connection data for modal
            currentConnection = {
                key: connectionKey,
                borderHostname: currentDragData.borderHostname,
                borderVlan: currentDragData.vlan,
                borderIp: currentDragData.ip,
                borderVrf: currentDragData.vrf,
                subnetMask: currentDragData.subnetMask,
                fusionRouterId: fusionRouterId,
                fusionHostname: fusionRouter.hostname,
                fusionIp: fusionIp
            };

            // Open modal immediately
            openConnectionModalFromData();
        }

        function updateGhostLine(event) {
            if (!isDragging || !currentDragData) return;

            const ghostLine = document.getElementById('dragGhostLine');
            if (!ghostLine) return;

            const svg = document.getElementById('topologySvg');
            const pt = svg.createSVGPoint();
            pt.x = event.clientX;
            pt.y = event.clientY;

            const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());

            // Show ghost line from sidebar edge to mouse
            ghostLine.setAttribute('x1', '0');
            ghostLine.setAttribute('y1', svgP.y);
            ghostLine.setAttribute('x2', svgP.x);
            ghostLine.setAttribute('y2', svgP.y);
            ghostLine.style.display = 'block';
        }

        // ============================================
        // ZOOM AND PAN FUNCTIONALITY
        // ============================================

        function initializePanZoom() {
            const container = document.getElementById('topologyContainer');
            const svg = document.getElementById('topologySvg');

            // Safety check: ensure both elements exist
            if (!container || !svg) {
                console.warn('Pan/zoom initialization skipped: missing container or SVG');
                return;
            }

            // Mouse wheel zoom
            svg.addEventListener('wheel', function(event) {
                event.preventDefault();
                const delta = event.deltaY > 0 ? -0.1 : 0.1;
                const newZoom = Math.max(0.3, Math.min(3.0, zoomLevel + delta));
                zoomLevel = newZoom;
                updateZoomTransform();
                updateZoomDisplay();
            });

            // Pan with mouse drag
            svg.addEventListener('mousedown', function(event) {
                if (event.target.tagName === 'svg' || event.target.id === 'mainGroup') {
                    isPanning = true;
                    lastPanX = event.clientX;
                    lastPanY = event.clientY;
                    container.classList.add('panning');
                }
            });

            document.addEventListener('mousemove', function(event) {
                if (!isPanning) return;

                const dx = event.clientX - lastPanX;
                const dy = event.clientY - lastPanY;

                panX += dx;
                panY += dy;

                lastPanX = event.clientX;
                lastPanY = event.clientY;

                updateZoomTransform();
            });

            document.addEventListener('mouseup', function(event) {
                if (isPanning) {
                    isPanning = false;
                    container.classList.remove('panning');
                }
            });
        }

        function updateZoomTransform() {
            const mainGroup = document.getElementById('mainGroup');
            if (!mainGroup) return;

            // Apply transform with proper order: translate then scale from origin
            // This ensures zoom happens from center and pan works correctly
            const svg = document.getElementById('topologySvg');
            if (!svg) return;

            const viewBox = svg.viewBox.baseVal;
            const centerX = viewBox.width / 2;
            const centerY = viewBox.height / 2;

            // Transform order: translate to origin, scale, translate back, then apply pan
            const transform = `translate(${centerX + panX}, ${centerY + panY}) scale(${zoomLevel}) translate(${-centerX}, ${-centerY})`;
            mainGroup.setAttribute('transform', transform);
        }

        function updateZoomDisplay() {
            const zoomLevelEl = document.getElementById('zoomLevel');
            if (zoomLevelEl) {
                zoomLevelEl.textContent = `${Math.round(zoomLevel * 100)}%`;
            }
        }

        function zoomIn() {
            zoomLevel = Math.min(3.0, zoomLevel + 0.2);
            updateZoomTransform();
            updateZoomDisplay();
        }

        function zoomOut() {
            zoomLevel = Math.max(0.3, zoomLevel - 0.2);
            updateZoomTransform();
            updateZoomDisplay();
        }

        function resetZoom() {
            zoomLevel = 1.0;
            panX = 0;
            panY = 0;
            updateZoomTransform();
            updateZoomDisplay();
        }

        // End of zoom and pan functions

        // ============================================
        // CONNECTION MANAGEMENT
        // ============================================

        function editConnection(connectionKey) {
            const config = connectionConfigs[connectionKey];
            if (!config) return;

            const fusionRouter = fusionRouters.find(r => r.router_id === config.fusion_router_id);
            if (!fusionRouter) return;

            currentConnection = {
                key: connectionKey,
                borderHostname: config.border_hostname,
                borderVlan: config.border_vlan_id,
                borderIp: config.border_ip,
                borderVrf: config.vrf_name,
                subnetMask: config.subnet_mask,
                fusionRouterId: config.fusion_router_id,
                fusionHostname: fusionRouter.hostname,
                fusionIp: config.fusion_ip
            };

            openConnectionModalFromData();
        }

        function deleteConnection(connectionKey) {
            if (!confirm('Are you sure you want to delete this connection?')) {
                return;
            }

            delete connectionConfigs[connectionKey];
            renderBorderNodeTables();
        }

        function openConnectionModalFromData() {
            if (!currentConnection) return;

            // Build form
            const formContainer = document.getElementById('connectionConfigForm');
            const existingConfig = connectionConfigs[currentConnection.key];
            const vrfStatus = currentConnection.borderVrf || 'Global Table';
            const needsVrfInput = !currentConnection.borderVrf;

            let html = `
                <div class="row mb-3">
                    <div class="col-md-6">
                        <h6 class="text-primary">Border Node</h6>
                        <p class="mb-1"><strong>Hostname:</strong> ${currentConnection.borderHostname}</p>
                        <p class="mb-1"><strong>VLAN:</strong> ${currentConnection.borderVlan}</p>
                        <p class="mb-1"><strong>IP Address:</strong> <span class="badge bg-info">${currentConnection.borderIp}</span></p>
                        <p class="mb-1"><strong>VRF:</strong> <span class="badge ${currentConnection.borderVrf ? 'vrf-badge' : 'bg-secondary'}">${vrfStatus}</span></p>
                    </div>
                    <div class="col-md-6">
                        <h6 class="text-success">Fusion Router</h6>
                        <p class="mb-1"><strong>Hostname:</strong> ${currentConnection.fusionHostname}</p>
                        <p class="mb-1"><strong>IP Address:</strong> <span class="badge bg-success">${currentConnection.fusionIp}</span></p>
                        <p class="mb-1"><strong>Subnet Mask:</strong> ${currentConnection.subnetMask}</p>
                    </div>
                </div>
                <hr>
                <div class="row">
                    <div class="col-12 mb-3">
                        <label class="form-label">VRF Name *</label>
                        <input type="text" class="form-control" id="modal_vrf_name"
                               placeholder="${needsVrfInput ? 'Required (e.g., INTERNET)' : currentConnection.borderVrf || 'INTERNET'}"
                               value="${existingConfig ? existingConfig.vrf_name : currentConnection.borderVrf || ''}"
                               required>
                        <div class="form-text">VRF name for this connection</div>
                    </div>
            `;

            if (currentInterfaceMode === 'routed') {
                html += `
                    <div class="col-md-6 mb-3">
                        <label class="form-label">Fusion Interface *</label>
                        <input type="text" class="form-control" id="modal_interface"
                               placeholder="GigabitEthernet0/0/1"
                               value="${existingConfig ? existingConfig.interface_name : ''}"
                               required>
                        <div class="form-text">Physical interface on fusion router</div>
                    </div>
                    <div class="col-md-6 mb-3">
                        <label class="form-label">Subinterface ID</label>
                        <input type="text" class="form-control" id="modal_routed_subif_id"
                               placeholder="${currentConnection.borderVlan}"
                               value="${existingConfig ? existingConfig.subif_id : ''}">
                        <div class="form-text">Optional subinterface number (leave empty for physical interface)</div>
                    </div>
                `;
            } else if (currentInterfaceMode === 'svi') {
                html += `
                    <div class="col-md-6 mb-3">
                        <label class="form-label">VLAN ID *</label>
                        <input type="text" class="form-control" id="modal_vlan_id"
                               placeholder="100"
                               value="${existingConfig ? existingConfig.vlan_id : ''}"
                               required>
                        <div class="form-text">VLAN for SVI interface</div>
                    </div>
                    <div class="col-md-6 mb-3">
                        <label class="form-label">Physical Interface *</label>
                        <input type="text" class="form-control" id="modal_physical_interface"
                               placeholder="GigabitEthernet0/0/1"
                               value="${existingConfig ? existingConfig.physical_interface : ''}"
                               required>
                        <div class="form-text">Physical trunk interface</div>
                    </div>
                `;
            } else if (currentInterfaceMode === 'subinterface') {
                html += `
                    <div class="col-md-6 mb-3">
                        <label class="form-label">Parent Interface *</label>
                        <input type="text" class="form-control" id="modal_parent_interface"
                               placeholder="GigabitEthernet0/0/1"
                               value="${existingConfig ? existingConfig.interface_name : ''}"
                               required>
                        <div class="form-text">Parent physical interface</div>
                    </div>
                    <div class="col-md-6 mb-3">
                        <label class="form-label">Subinterface ID *</label>
                        <input type="text" class="form-control" id="modal_subif_id"
                               placeholder="${currentConnection.borderVlan}"
                               value="${existingConfig ? existingConfig.subif_id : currentConnection.borderVlan}"
                               required>
                        <div class="form-text">Subinterface number</div>
                    </div>
                `;
            }

            html += `
                </div>
            `;

            formContainer.innerHTML = html;

            // Show modal
            const modal = new bootstrap.Modal(document.getElementById('connectionModal'));
            modal.show();
        }

        function saveConnectionConfig() {
            const vrfName = document.getElementById('modal_vrf_name').value.trim();

            if (!vrfName) {
                alert('VRF name is required');
                return;
            }

            const config = {
                border_hostname: currentConnection.borderHostname,
                border_vlan_id: currentConnection.borderVlan,
                fusion_router_id: currentConnection.fusionRouterId,
                interface_mode: currentInterfaceMode,
                vrf_name: vrfName,
                border_ip: currentConnection.borderIp,
                fusion_ip: currentConnection.fusionIp,
                subnet_mask: currentConnection.subnetMask
            };

            if (currentInterfaceMode === 'routed') {
                config.interface_name = document.getElementById('modal_interface').value.trim();
                const subifId = document.getElementById('modal_routed_subif_id').value.trim();
                if (!config.interface_name) {
                    alert('Interface name is required');
                    return;
                }
                // Add subinterface ID if provided
                if (subifId) {
                    config.subif_id = subifId;
                }
            } else if (currentInterfaceMode === 'svi') {
                config.vlan_id = document.getElementById('modal_vlan_id').value.trim();
                config.physical_interface = document.getElementById('modal_physical_interface').value.trim();
                if (!config.vlan_id || !config.physical_interface) {
                    alert('VLAN ID and Physical Interface are required');
                    return;
                }
            } else if (currentInterfaceMode === 'subinterface') {
                config.interface_name = document.getElementById('modal_parent_interface').value.trim();
                config.subif_id = document.getElementById('modal_subif_id').value.trim();
                if (!config.interface_name || !config.subif_id) {
                    alert('Parent interface and Subinterface ID are required');
                    return;
                }
            }

            // Save configuration
            connectionConfigs[currentConnection.key] = config;

            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('connectionModal'));
            modal.hide();

            // Re-render table to update visual state
            renderBorderNodeTables();
        }

        function calculateFusionIP(borderNodeIP) {
            const parts = borderNodeIP.split('.').map(Number);
            const lastOctet = parts[3];
            const networkBase = Math.floor(lastOctet / 4) * 4;

            if (lastOctet === networkBase + 1) {
                parts[3] = networkBase + 2;
            } else if (lastOctet === networkBase + 2) {
                parts[3] = networkBase + 1;
            }

            return parts.join('.');
        }

        function proceedToStep5() {
            // Collect handoff configurations from connectionConfigs
            handoffs = [];

            if (Object.keys(connectionConfigs).length === 0) {
                alert('Please configure at least one interface handoff by selecting a Fusion router and interface.');
                return;
            }

            // Convert connectionConfigs to handoffs array
            for (const connectionKey in connectionConfigs) {
                handoffs.push(connectionConfigs[connectionKey]);
            }

            // Extract unique VRF names
            displayVrfConfiguration();
            showStep(5);
        }

        function displayVrfConfiguration() {
            const uniqueVrfs = [...new Set(handoffs.map(h => h.vrf_name))];
            const container = document.getElementById('vrfConfigSection');
            let html = '';

            // Add iBGP VRF Selection (if iBGP is enabled)
            const ibgpEnabled = document.getElementById('enableIbgp')?.checked;
            if (ibgpEnabled && uniqueVrfs.length > 0) {
                html += `
                    <div class="card mb-3" style="border-color: #667eea;">
                        <div class="card-header" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                            <h6 class="mb-0"><i class="fas fa-exchange-alt"></i> iBGP VRF Selection</h6>
                        </div>
                        <div class="card-body">
                            <p class="text-muted mb-3">Select which VRFs should have iBGP peering enabled between fusion routers:</p>
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="form-check mb-2">
                                        <input class="form-check-input" type="checkbox" id="ibgp_vrf_global" value="global">
                                        <label class="form-check-label" for="ibgp_vrf_global">
                                            <strong>Global Routing Table</strong>
                                        </label>
                                    </div>
                                </div>
                            </div>
                            <div class="row">
                `;

                uniqueVrfs.forEach((vrfName, idx) => {
                    html += `
                        <div class="col-md-6">
                            <div class="form-check mb-2">
                                <input class="form-check-input" type="checkbox" id="ibgp_vrf_${idx}" value="${vrfName}" checked>
                                <label class="form-check-label" for="ibgp_vrf_${idx}">
                                    <strong>VRF: ${vrfName}</strong>
                                </label>
                            </div>
                        </div>
                    `;
                });

                html += `
                            </div>
                            <hr class="my-3">
                            <div class="form-check mb-2">
                                <input class="form-check-input" type="checkbox" id="ibgp_use_vpnv4" checked>
                                <label class="form-check-label" for="ibgp_use_vpnv4">
                                    <strong>Use VPNv4 Address-Family</strong> (Recommended for multi-VRF)
                                </label>
                            </div>
                            <div class="alert alert-info mt-2 mb-0">
                                <i class="fas fa-lightbulb"></i> <strong>VPNv4 Mode:</strong> When enabled, VRF routes are exchanged via the VPNv4 address-family with Route Targets. This is the correct method for multi-VRF iBGP. When disabled, iBGP neighbors are configured separately in each VRF address-family.
                            </div>
                        </div>
                    </div>
                `;
            }

            // Add OSPF VRF Selection (if OSPF is enabled)
            const ospfEnabled = document.getElementById('enableIbgp')?.checked; // OSPF shown when iBGP enabled
            if (ospfEnabled && uniqueVrfs.length > 0) {
                html += `
                    <div class="card mb-3" style="border-color: #28a745;">
                        <div class="card-header" style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%); color: white;">
                            <h6 class="mb-0"><i class="fas fa-route"></i> OSPF VRF Selection</h6>
                        </div>
                        <div class="card-body">
                            <p class="text-muted mb-3">Select which VRF should run OSPF for router interconnect:</p>
                            <div class="alert alert-warning">
                                <i class="fas fa-exclamation-triangle"></i> <strong>Note:</strong> OSPF underlay typically runs in the global routing table for fusion router interconnection. VRF-aware OSPF is for advanced scenarios.
                            </div>
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="form-check mb-2">
                                        <input class="form-check-input" type="radio" name="ospf_vrf_selection" id="ospf_vrf_global" value="global" checked>
                                        <label class="form-check-label" for="ospf_vrf_global">
                                            <strong>Global Routing Table (Recommended)</strong>
                                        </label>
                                    </div>
                                </div>
                            </div>
                            <div class="row">
                `;

                uniqueVrfs.forEach((vrfName, idx) => {
                    html += `
                        <div class="col-md-6">
                            <div class="form-check mb-2">
                                <input class="form-check-input" type="radio" name="ospf_vrf_selection" id="ospf_vrf_${idx}" value="${vrfName}">
                                <label class="form-check-label" for="ospf_vrf_${idx}">
                                    <strong>VRF: ${vrfName}</strong>
                                </label>
                            </div>
                        </div>
                    `;
                });

                html += `
                            </div>
                        </div>
                    </div>
                `;
            }

            // VRF Configuration Sections
            uniqueVrfs.forEach((vrfName, index) => {
                html += `
                    <div class="vrf-config-section">
                        <h6><i class="fas fa-project-diagram"></i> VRF: ${vrfName}</h6>
                        <div class="row">
                            <div class="col-md-4 mb-3">
                                <label for="vrf_rd_${index}" class="form-label">Route Distinguisher (RD) *</label>
                                <input type="text" class="form-control" id="vrf_rd_${index}"
                                       placeholder="65000:${100 + index}" required
                                       data-vrf-name="${vrfName}">
                                <div class="form-text">Format: ASN:NN or IP:NN</div>
                            </div>
                            <div class="col-md-4 mb-3">
                                <label class="form-label">Route Target Export</label>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox"
                                           id="vrf_rt_exp_enable_${index}"
                                           onchange="toggleRtField('exp', ${index})">
                                    <label class="form-check-label" for="vrf_rt_exp_enable_${index}">
                                        Enable RT Export
                                    </label>
                                </div>
                                <input type="text" class="form-control mt-2" id="vrf_rt_exp_${index}"
                                       placeholder="65000:${100 + index}" disabled>
                            </div>
                            <div class="col-md-4 mb-3">
                                <label class="form-label">Route Target Import</label>
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox"
                                           id="vrf_rt_imp_enable_${index}"
                                           onchange="toggleRtField('imp', ${index})">
                                    <label class="form-check-label" for="vrf_rt_imp_enable_${index}">
                                        Enable RT Import
                                    </label>
                                </div>
                                <input type="text" class="form-control mt-2" id="vrf_rt_imp_${index}"
                                       placeholder="65000:${200 + index}" disabled>
                            </div>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function toggleRtField(type, index) {
            const checkbox = document.getElementById(`vrf_rt_${type}_enable_${index}`);
            const input = document.getElementById(`vrf_rt_${type}_${index}`);
            input.disabled = !checkbox.checked;
        }

        async function generateConfiguration() {
            try {
                // Collect VRF configurations
                const uniqueVrfs = [...new Set(handoffs.map(h => h.vrf_name))];
                const vrfConfigs = [];

                uniqueVrfs.forEach((vrfName, index) => {
                    const rd = document.getElementById(`vrf_rd_${index}`).value.trim();
                    if (!rd) {
                        throw new Error(`Route Distinguisher is required for VRF ${vrfName}`);
                    }

                    const vrf = {
                        name: vrfName,
                        rd: rd,
                        rt_export_enabled: document.getElementById(`vrf_rt_exp_enable_${index}`).checked,
                        rt_import_enabled: document.getElementById(`vrf_rt_imp_enable_${index}`).checked
                    };

                    if (vrf.rt_export_enabled) {
                        vrf.rt_export_value = document.getElementById(`vrf_rt_exp_${index}`).value.trim();
                        if (!vrf.rt_export_value) {
                            throw new Error(`RT Export value is required for VRF ${vrfName}`);
                        }
                    }

                    if (vrf.rt_import_enabled) {
                        vrf.rt_import_value = document.getElementById(`vrf_rt_imp_${index}`).value.trim();
                        if (!vrf.rt_import_value) {
                            throw new Error(`RT Import value is required for VRF ${vrfName}`);
                        }
                    }

                    vrfConfigs.push(vrf);
                });

                // Collect iBGP parameters with VRF awareness
                let ibgpParams = null;
                if (document.getElementById('enableIbgp')?.checked) {
                    // Collect selected VRFs for iBGP
                    const ibgpVrfs = [];

                    // Check if global table is selected
                    if (document.getElementById('ibgp_vrf_global')?.checked) {
                        ibgpVrfs.push(null); // null represents global table
                    }

                    // Check each VRF checkbox
                    uniqueVrfs.forEach((vrfName, idx) => {
                        const checkbox = document.getElementById(`ibgp_vrf_${idx}`);
                        if (checkbox && checkbox.checked) {
                            ibgpVrfs.push(vrfName);
                        }
                    });

                    ibgpParams = {
                        enabled: true,
                        vrfs: ibgpVrfs, // List of VRFs to enable iBGP in
                        use_vpnv4: document.getElementById('ibgp_use_vpnv4')?.checked || false, // Use VPNv4 for VRF routes
                        bfd_enabled: document.getElementById('ibgpBfdEnabled').checked,
                        bfd_interval: 250,
                        bfd_min_rx: 250,
                        bfd_multiplier: 3
                    };
                }

                // Collect OSPF parameters with VRF awareness
                let ospfParams = null;
                if (document.getElementById('enableIbgp')?.checked) {
                    const ospfMode = document.querySelector('input[name="ospfInterfaceMode"]:checked').value;

                    // Determine which VRF OSPF should run in
                    let ospfVrf = null;
                    const ospfVrfSelection = document.querySelector('input[name="ospf_vrf_selection"]:checked');
                    if (ospfVrfSelection && ospfVrfSelection.value !== 'global') {
                        ospfVrf = ospfVrfSelection.value;
                    }

                    ospfParams = {
                        enabled: true,
                        vrf: ospfVrf, // VRF for OSPF (null = global table)
                        process_id: parseInt(document.getElementById('ospfProcessId').value),
                        area: parseInt(document.getElementById('ospfArea').value),
                        interface_mode: ospfMode,
                        router1_interface: document.getElementById('ospfRouter1Interface').value.trim(),
                        router1_ip: document.getElementById('ospfRouter1Ip').value.trim(),
                        router2_interface: document.getElementById('ospfRouter2Interface').value.trim(),
                        router2_ip: document.getElementById('ospfRouter2Ip').value.trim(),
                        subnet_mask: document.getElementById('ospfSubnetMask').value,
                        bfd_enabled: document.getElementById('ospfBfdEnabled').checked,
                        bfd_interval: parseInt(document.getElementById('ospfBfdInterval').value),
                        bfd_min_rx: parseInt(document.getElementById('ospfBfdMinRx').value),
                        bfd_multiplier: parseInt(document.getElementById('ospfBfdMultiplier').value),
                        authentication: document.getElementById('ospfAuth').value
                    };

                    // Add VLAN ID for SVI and subinterface modes
                    if (ospfMode === 'svi' || ospfMode === 'subinterface') {
                        ospfParams.vlan_id = parseInt(document.getElementById('ospfVlanId').value);
                    }

                    // Add cost if provided
                    const costValue = document.getElementById('ospfCost').value.trim();
                    if (costValue) {
                        ospfParams.cost = parseInt(costValue);
                    }

                    // Add MD5 authentication params if enabled
                    if (ospfParams.authentication === 'md5') {
                        ospfParams.md5_key_id = parseInt(document.getElementById('ospfKeyId').value);
                        ospfParams.md5_key = document.getElementById('ospfKeyString').value.trim();

                        if (!ospfParams.md5_key) {
                            throw new Error('MD5 key is required when MD5 authentication is enabled');
                        }
                    }

                    // Validate required fields
                    if (!ospfParams.router1_interface || !ospfParams.router1_ip ||
                        !ospfParams.router2_interface || !ospfParams.router2_ip) {
                        throw new Error('All OSPF interface fields are required');
                    }

                    // Validate interface name format
                    const router1Result = validateInterfaceName(ospfParams.router1_interface);
                    if (!router1Result.valid) {
                        throw new Error(`Router 1 Interface: ${router1Result.error}`);
                    }

                    const router2Result = validateInterfaceName(ospfParams.router2_interface);
                    if (!router2Result.valid) {
                        throw new Error(`Router 2 Interface: ${router2Result.error}`);
                    }
                }

                // Prepare request data
                const requestData = {
                    fusion_routers: fusionRouters,
                    border_nodes: borderNodeConfigs,
                    handoffs: handoffs,
                    vrf_configs: vrfConfigs,
                    ibgp_params: ibgpParams,
                    ospf_params: ospfParams
                };

                const response = await fetch('/generate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });

                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || 'Generation failed');
                }

                generatedConfigs = data.configs;
                displayConfigPreviews(generatedConfigs, data.saved_files, data.summary_file);
                showStep(6);

            } catch (error) {
                alert('Error: ' + error.message);
            }
        }

        function displayConfigPreviews(configs, savedFiles, summaryFile) {
            const tabsContainer = document.getElementById('configTabs');
            const contentContainer = document.getElementById('configTabContent');

            let tabsHtml = '';
            let contentHtml = '';
            let isFirst = true;

            Object.keys(configs).forEach(hostname => {
                const tabId = hostname.replace(/[^a-zA-Z0-9]/g, '_');

                tabsHtml += `
                    <li class="nav-item" role="presentation">
                        <button class="nav-link ${isFirst ? 'active' : ''}" id="${tabId}-tab"
                                data-bs-toggle="tab" data-bs-target="#${tabId}"
                                type="button" role="tab">
                            ${hostname}
                        </button>
                    </li>
                `;

                contentHtml += `
                    <div class="tab-pane fade ${isFirst ? 'show active' : ''}"
                         id="${tabId}" role="tabpanel">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <h6>${hostname} Configuration</h6>
                            <button class="btn btn-success btn-sm" onclick="downloadSingleConfig('${hostname}')">
                                <i class="fas fa-download"></i> Download
                            </button>
                        </div>
                        <div class="config-preview">${escapeHtml(configs[hostname])}</div>
                    </div>
                `;

                isFirst = false;
            });

            tabsContainer.innerHTML = tabsHtml;
            contentContainer.innerHTML = contentHtml;

            // Add notification for saved files
            if (savedFiles && savedFiles.length > 0) {
                let savedMsg = '<div class="alert alert-info mt-3">' +
                               '<h6><i class="fas fa-save"></i> Configurations automatically saved to outputs/</h6>' +
                               '<ul class="mb-0">';
                savedFiles.forEach(file => {
                    savedMsg += `<li><code>${file.filename}</code></li>`;
                });
                if (summaryFile) {
                    savedMsg += `<li><code>${summaryFile}</code> (generation summary)</li>`;
                }
                savedMsg += '</ul></div>';

                contentContainer.insertAdjacentHTML('beforeend', savedMsg);
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function downloadSingleConfig(hostname) {
            const config = generatedConfigs[hostname];
            const filename = `${hostname}-config.txt`;

            try {
                const response = await fetch('/download', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        config: config,
                        filename: filename
                    })
                });

                if (!response.ok) {
                    throw new Error('Download failed');
                }

                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);

            } catch (error) {
                alert('Error: ' + error.message);
            }
        }

        async function downloadAllConfigs() {
            for (const hostname of Object.keys(generatedConfigs)) {
                await downloadSingleConfig(hostname);
                // Small delay between downloads
                await new Promise(resolve => setTimeout(resolve, 500));
            }
        }
    </script>
</body>
</html>
